name: "Go PR Analysis"

# Reusable workflow for Go PR analysis in monorepos
# Handles change detection, CI, security, and coverage checks per changed app
# All logic is centralized here for easy maintenance

on:
  workflow_call:
    inputs:
      runner_type:
        description: 'GitHub runner type'
        type: string
        default: 'blacksmith-4vcpu-ubuntu-2404'
      filter_paths:
        description: 'JSON array of paths to monitor for changes (e.g., ["apps/api", "apps/worker"]). If empty, treats repo as single-app and runs against root directory.'
        type: string
        required: false
        default: ''
      path_level:
        description: 'Directory depth level to extract app name'
        type: number
        default: 2
      app_name_prefix:
        description: 'Prefix for app names in matrix output'
        type: string
        default: ''
      go_version:
        description: 'Go version to use'
        type: string
        default: '1.23'
      golangci_lint_version:
        description: 'GolangCI-Lint version'
        type: string
        default: 'v1.62.2'
      golangci_lint_args:
        description: 'Additional arguments for golangci-lint'
        type: string
        default: '--timeout=5m'
      coverage_threshold:
        description: 'Minimum coverage percentage required (0-100)'
        type: number
        default: 80
      fail_on_coverage_threshold:
        description: 'Fail the workflow if coverage is below threshold'
        type: boolean
        default: false
      enable_lint:
        description: 'Enable GolangCI-Lint'
        type: boolean
        default: true
      enable_security:
        description: 'Enable security scanning (gosec, govulncheck)'
        type: boolean
        default: true
      enable_tests:
        description: 'Enable unit tests'
        type: boolean
        default: true
      enable_coverage:
        description: 'Enable coverage check with PR comment'
        type: boolean
        default: true
      enable_build:
        description: 'Enable build verification'
        type: boolean
        default: true
      go_private_modules:
        description: 'GOPRIVATE pattern for private Go modules (e.g., github.com/LerianStudio/*)'
        type: string
        default: ''

permissions:
  contents: read
  pull-requests: write
  security-events: write

jobs:
  # ============================================
  # CHANGE DETECTION
  # ============================================
  detect-changes:
    name: Detect Changes
    runs-on: ${{ inputs.runner_type }}
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
      has_changes: ${{ steps.set-matrix.outputs.has_changes }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Get changed files
        id: changed
        shell: bash
        run: |
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            # For PRs, compare base and head
            BASE_SHA="${{ github.event.pull_request.base.sha }}"
            HEAD_SHA="${{ github.event.pull_request.head.sha }}"
            git fetch origin $BASE_SHA --depth=1 2>/dev/null || true
            FILES=$(git diff --name-only $BASE_SHA $HEAD_SHA 2>/dev/null || git diff --name-only origin/${{ github.base_ref }}...HEAD)
          elif [[ "${{ github.event.before }}" == "0000000000000000000000000000000000000000" ]] || [[ -z "${{ github.event.before }}" ]]; then
            PREV_COMMIT=$(git rev-parse HEAD^)
            if [[ $? -eq 0 ]]; then
              FILES=$(git diff --name-only $PREV_COMMIT HEAD)
            else
              FILES=$(git ls-tree -r --name-only HEAD)
            fi
          else
            FILES=$(git diff --name-only ${{ github.event.before }} ${{ github.sha }})
          fi
          printf "files<<EOF\n%s\nEOF\n" "$FILES" >> "$GITHUB_OUTPUT"

      - name: Build matrix from changed paths
        id: set-matrix
        shell: bash
        run: |
          FILES="${{ steps.changed.outputs.files }}"
          FILTER_PATHS='${{ inputs.filter_paths }}'
          PATH_LEVEL="${{ inputs.path_level }}"
          APP_NAME_PREFIX="${{ inputs.app_name_prefix }}"

          if [[ -z "$FILES" ]]; then
            echo "No files changed."
            echo "matrix=[]" >> "$GITHUB_OUTPUT"
            echo "has_changes=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Single-app mode: if filter_paths is empty, run against root directory
          if [[ -z "$FILTER_PATHS" ]] || [[ "$FILTER_PATHS" == "[]" ]] || [[ "$FILTER_PATHS" == "" ]]; then
            echo "Single-app mode: no filter_paths specified, running against root directory"
            if [[ -n "$APP_NAME_PREFIX" ]]; then
              APP_NAME="$APP_NAME_PREFIX"
            else
              APP_NAME="app"
            fi
            MATRIX="[{\"name\":\"$APP_NAME\",\"working_dir\":\".\"}]"
            echo "Single app matrix: $MATRIX"
            echo "matrix=$MATRIX" >> "$GITHUB_OUTPUT"
            echo "has_changes=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Monorepo mode: filter and build matrix from changed paths
          echo "Monorepo mode: filtering by paths $FILTER_PATHS"

          # Get directory for each file
          DIRS=$(echo "$FILES" | xargs -n1 dirname)

          # Trim to first N path segments
          if [[ -n "$PATH_LEVEL" ]] && [[ "$PATH_LEVEL" -gt 0 ]]; then
            DIRS=$(echo "$DIRS" | cut -d'/' -f-"$PATH_LEVEL")
          fi

          # Filter paths
          FILTER_LIST=$(echo "$FILTER_PATHS" | jq -r '.[]' 2>/dev/null || echo "")
          if [[ -n "$FILTER_LIST" ]]; then
            FILTERED=""
            while read -r DIR; do
              while read -r FILTER; do
                if [[ "$DIR" == "$FILTER"* ]]; then
                  FILTERED+="$DIR"$'\n'
                  break
                fi
              done <<< "$FILTER_LIST"
            done <<< "$DIRS"
            DIRS="$FILTERED"
          fi

          # Deduplicate and remove empty lines
          DIRS=$(echo "$DIRS" | grep -v '^$' | sort -u || true)

          if [[ -z "$DIRS" ]]; then
            echo "No matching directories found."
            echo "matrix=[]" >> "$GITHUB_OUTPUT"
            echo "has_changes=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Build matrix with app names
          MATRIX="["
          FIRST=true
          while read -r DIR; do
            if [[ -n "$APP_NAME_PREFIX" ]]; then
              APP_NAME="${APP_NAME_PREFIX}-$(echo "$DIR" | rev | cut -d'/' -f1 | rev)"
            else
              APP_NAME="$(echo "$DIR" | rev | cut -d'/' -f1 | rev)"
            fi
            ENTRY="{\"name\":\"$APP_NAME\",\"working_dir\":\"$DIR\"}"
            if $FIRST; then
              MATRIX+="$ENTRY"
              FIRST=false
            else
              MATRIX+=",$ENTRY"
            fi
          done <<< "$DIRS"
          MATRIX+="]"

          echo "Changed apps matrix: $MATRIX"
          echo "matrix=$MATRIX" >> "$GITHUB_OUTPUT"
          echo "has_changes=true" >> "$GITHUB_OUTPUT"

  # ============================================
  # GOLANGCI-LINT
  # ============================================
  lint:
    name: Lint (${{ matrix.app.name }})
    needs: detect-changes
    if: needs.detect-changes.outputs.has_changes == 'true' && inputs.enable_lint
    runs-on: ${{ inputs.runner_type }}
    strategy:
      fail-fast: false
      matrix:
        app: ${{ fromJson(needs.detect-changes.outputs.matrix) }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ inputs.go_version }}
          cache: true

      - name: Configure private Go modules
        if: inputs.go_private_modules != ''
        run: |
          git config --global url."https://${{ secrets.MANAGE_TOKEN }}@github.com/".insteadOf "https://github.com/"
        env:
          GOPRIVATE: ${{ inputs.go_private_modules }}

      - name: Run GolangCI-Lint
        uses: golangci/golangci-lint-action@v9
        with:
          version: ${{ inputs.golangci_lint_version }}
          working-directory: ${{ matrix.app.working_dir }}
          args: ${{ inputs.golangci_lint_args }}

  # ============================================
  # SECURITY SCANNING
  # ============================================
  security:
    name: Security (${{ matrix.app.name }})
    needs: detect-changes
    if: needs.detect-changes.outputs.has_changes == 'true' && inputs.enable_security
    runs-on: ${{ inputs.runner_type }}
    strategy:
      fail-fast: false
      matrix:
        app: ${{ fromJson(needs.detect-changes.outputs.matrix) }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ inputs.go_version }}
          cache: true

      - name: Configure private Go modules
        if: inputs.go_private_modules != ''
        run: |
          git config --global url."https://${{ secrets.MANAGE_TOKEN }}@github.com/".insteadOf "https://github.com/"
        env:
          GOPRIVATE: ${{ inputs.go_private_modules }}

      - name: Run Gosec
        uses: securego/gosec@v2.22.10
        with:
          args: -no-fail -fmt sarif -out gosec-${{ matrix.app.name }}.sarif ./${{ matrix.app.working_dir }}/...

      - name: Upload Gosec SARIF
        if: always()
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: gosec-${{ matrix.app.name }}.sarif
          category: gosec-${{ matrix.app.name }}
        continue-on-error: true

      - name: Install govulncheck
        run: go install golang.org/x/vuln/cmd/govulncheck@latest

      - name: Run govulncheck
        working-directory: ${{ matrix.app.working_dir }}
        run: govulncheck ./...
        continue-on-error: true

  # ============================================
  # UNIT TESTS
  # ============================================
  tests:
    name: Tests (${{ matrix.app.name }})
    needs: detect-changes
    if: needs.detect-changes.outputs.has_changes == 'true' && inputs.enable_tests
    runs-on: ${{ inputs.runner_type }}
    strategy:
      fail-fast: false
      matrix:
        app: ${{ fromJson(needs.detect-changes.outputs.matrix) }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ inputs.go_version }}
          cache: true

      - name: Configure private Go modules
        if: inputs.go_private_modules != ''
        run: |
          git config --global url."https://${{ secrets.MANAGE_TOKEN }}@github.com/".insteadOf "https://github.com/"
        env:
          GOPRIVATE: ${{ inputs.go_private_modules }}

      - name: Download dependencies
        working-directory: ${{ matrix.app.working_dir }}
        run: go mod download

      - name: Run tests
        working-directory: ${{ matrix.app.working_dir }}
        env:
          CGO_ENABLED: 1
        run: go test -v -race -coverprofile=coverage.txt -covermode=atomic ./...

      - name: Upload coverage artifact
        uses: actions/upload-artifact@v4
        with:
          name: coverage-${{ matrix.app.name }}
          path: ${{ matrix.app.working_dir }}/coverage.txt
          retention-days: 7

  # ============================================
  # COVERAGE CHECK
  # ============================================
  coverage:
    name: Coverage (${{ matrix.app.name }})
    needs: [detect-changes, tests]
    if: needs.detect-changes.outputs.has_changes == 'true' && inputs.enable_coverage
    runs-on: ${{ inputs.runner_type }}
    strategy:
      fail-fast: false
      matrix:
        app: ${{ fromJson(needs.detect-changes.outputs.matrix) }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ inputs.go_version }}
          cache: true

      - name: Configure private Go modules
        if: inputs.go_private_modules != ''
        run: |
          git config --global url."https://${{ secrets.MANAGE_TOKEN }}@github.com/".insteadOf "https://github.com/"
        env:
          GOPRIVATE: ${{ inputs.go_private_modules }}

      - name: Download coverage artifact
        uses: actions/download-artifact@v6
        with:
          name: coverage-${{ matrix.app.name }}
          path: ${{ matrix.app.working_dir }}

      - name: Calculate coverage
        id: coverage
        working-directory: ${{ matrix.app.working_dir }}
        run: |
          if [[ -f coverage.txt ]]; then
            COVERAGE=$(go tool cover -func=coverage.txt | grep total | awk '{print $3}' | sed 's/%//')
            echo "coverage=$COVERAGE" >> $GITHUB_OUTPUT
            echo "Total coverage: $COVERAGE%"

            # Generate coverage by package table
            echo "## Coverage by Package" > coverage-report.md
            echo "" >> coverage-report.md
            echo "| Package | Coverage |" >> coverage-report.md
            echo "|---------|----------|" >> coverage-report.md

            # Aggregate coverage by package
            go tool cover -func=coverage.txt | grep -v "total:" | awk '
            {
              if (NF >= 3) {
                split($1, parts, ":");
                filepath = parts[1];
                split(filepath, pathparts, "/");
                n = length(pathparts);
                pkg = "";
                for (i = 1; i < n; i++) {
                  if (i > 1) pkg = pkg "/";
                  pkg = pkg pathparts[i];
                }
                cov_str = $NF;
                gsub(/%/, "", cov_str);
                cov = cov_str + 0;
                pkg_lines[pkg] += 1;
                pkg_coverage[pkg] += cov;
              }
            }
            END {
              for (p in pkg_coverage) {
                if (pkg_lines[p] > 0) {
                  avg = pkg_coverage[p] / pkg_lines[p];
                  printf "| `%s` | %.1f%% |\n", p, avg;
                }
              }
            }' | sort >> coverage-report.md
          else
            echo "coverage=0" >> $GITHUB_OUTPUT
            echo "No coverage file found"
            echo "No coverage data available" > coverage-report.md
          fi

      - name: Generate HTML coverage report
        working-directory: ${{ matrix.app.working_dir }}
        run: |
          if [[ -f coverage.txt ]]; then
            go tool cover -html=coverage.txt -o coverage.html
          fi

      - name: Upload coverage report
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report-${{ matrix.app.name }}
          path: |
            ${{ matrix.app.working_dir }}/coverage.txt
            ${{ matrix.app.working_dir }}/coverage.html
            ${{ matrix.app.working_dir }}/coverage-report.md
          retention-days: 30

      - name: Check coverage threshold
        if: inputs.fail_on_coverage_threshold
        run: |
          COVERAGE=${{ steps.coverage.outputs.coverage }}
          THRESHOLD=${{ inputs.coverage_threshold }}
          if (( $(echo "$COVERAGE < $THRESHOLD" | bc -l) )); then
            echo "::error::Coverage $COVERAGE% is below threshold $THRESHOLD%"
            exit 1
          fi

      - name: Post coverage comment
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.MANAGE_TOKEN || github.token }}
          script: |
            const fs = require('fs');
            const coverage = '${{ steps.coverage.outputs.coverage }}';
            const threshold = '${{ inputs.coverage_threshold }}';
            const appName = '${{ matrix.app.name }}';
            const workingDir = '${{ matrix.app.working_dir }}';
            const passFail = parseFloat(coverage) >= parseFloat(threshold) ? 'âœ… PASS' : 'âš ï¸ BELOW THRESHOLD';

            let coverageReport = '';
            try {
              const path = require('path');
              const fullPath = path.join(process.cwd(), workingDir, 'coverage-report.md');
              console.log('Reading coverage report from:', fullPath);
              coverageReport = fs.readFileSync(fullPath, 'utf8');
              console.log('Coverage report content length:', coverageReport.length);
            } catch (err) {
              console.log('Error reading coverage report:', err.message);
              coverageReport = 'Coverage report not available';
            }

            const body = `## ðŸ“Š Unit Test Coverage Report: \`${appName}\`

            | Metric | Value |
            |--------|-------|
            | **Overall Coverage** | \`${coverage}%\` ${passFail} |
            | **Threshold** | \`${threshold}%\` |

            ${coverageReport}

            ---
            *Generated by Go PR Analysis workflow*`;

            // Find and update existing comment or create new one
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const botComment = comments.find(comment => 
              comment.body.includes(`Unit Test Coverage Report: \`${appName}\``)
            );

            if (botComment) {
              console.log('Updating existing comment:', botComment.id);
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: body
              });
              console.log('Comment updated successfully');
            } else {
              console.log('Creating new comment');
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: body
              });
              console.log('Comment created successfully');
            }

      - name: Coverage summary
        working-directory: ${{ matrix.app.working_dir }}
        run: |
          echo "## Coverage Summary: ${{ matrix.app.name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Total Coverage**: ${{ steps.coverage.outputs.coverage }}%" >> $GITHUB_STEP_SUMMARY
          echo "- **Threshold**: ${{ inputs.coverage_threshold }}%" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [[ -f coverage.txt ]]; then
            echo "### Coverage by Function" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            go tool cover -func=coverage.txt >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
          fi

  # ============================================
  # BUILD VERIFICATION
  # ============================================
  build:
    name: Build (${{ matrix.app.name }})
    needs: detect-changes
    if: needs.detect-changes.outputs.has_changes == 'true' && inputs.enable_build
    runs-on: ${{ inputs.runner_type }}
    strategy:
      fail-fast: false
      matrix:
        app: ${{ fromJson(needs.detect-changes.outputs.matrix) }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ inputs.go_version }}
          cache: true

      - name: Configure private Go modules
        if: inputs.go_private_modules != ''
        run: |
          git config --global url."https://${{ secrets.MANAGE_TOKEN }}@github.com/".insteadOf "https://github.com/"
        env:
          GOPRIVATE: ${{ inputs.go_private_modules }}

      - name: Download dependencies
        working-directory: ${{ matrix.app.working_dir }}
        run: go mod download

      - name: Build
        working-directory: ${{ matrix.app.working_dir }}
        run: go build -v ./...

  # ============================================
  # NO CHANGES DETECTED
  # ============================================
  no-changes:
    name: No Go Changes
    needs: detect-changes
    if: needs.detect-changes.outputs.has_changes != 'true'
    runs-on: ${{ inputs.runner_type }}
    steps:
      - name: Skip
        run: |
          echo "No Go code changes detected in monitored paths."
          echo "Skipping Go analysis workflows."

  # ============================================
  # SLACK NOTIFICATION
  # ============================================
  notify:
    name: Notify
    needs: [detect-changes, lint, security, tests, build]
    if: always() && needs.detect-changes.outputs.has_changes == 'true'
    uses: ./.github/workflows/slack-notify.yml
    with:
      status: ${{ (needs.lint.result == 'failure' || needs.security.result == 'failure' || needs.tests.result == 'failure' || needs.build.result == 'failure') && 'failure' || 'success' }}
      workflow_name: "Go PR Analysis"
      failed_jobs: ${{ needs.lint.result == 'failure' && 'Lint, ' || '' }}${{ needs.security.result == 'failure' && 'Security, ' || '' }}${{ needs.tests.result == 'failure' && 'Tests, ' || '' }}${{ needs.build.result == 'failure' && 'Build' || '' }}
    secrets:
      SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
