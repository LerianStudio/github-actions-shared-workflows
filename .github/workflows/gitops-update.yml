name: "GitOps Update"

# Reusable workflow for updating GitOps repository with new image tags
# Supports multiple environments: dev (beta), stg (rc), prd (production), sandbox
# Handles single or multiple components with flexible YAML key mapping

on:
  workflow_call:
    inputs:
      gitops_repository:
        description: 'GitOps repository to update (org/repo format)'
        type: string
        default: 'LerianStudio/midaz-firmino-gitops'
      gitops_server:
        description: 'Server name for GitOps path (e.g., firmino)'
        type: string
        default: 'firmino'
      app_name:
        description: 'Application name (defaults to repository name if not provided)'
        type: string
        required: false
      gitops_file_dev:
        description: 'Path to dev environment values.yaml (auto-generated if not provided)'
        type: string
        required: false
      gitops_file_stg:
        description: 'Path to stg environment values.yaml (auto-generated if not provided)'
        type: string
        required: false
      gitops_file_prd:
        description: 'Path to prd environment values.yaml (auto-generated if not provided)'
        type: string
        required: false
      gitops_file_sandbox:
        description: 'Path to sandbox environment values.yaml (auto-generated if not provided)'
        type: string
        required: false
      artifact_pattern:
        description: 'Pattern to download artifacts (defaults to "gitops-tags-<repo-name>-*" if not provided)'
        type: string
        required: false
      yaml_key_mappings:
        description: 'JSON object mapping artifact names to YAML keys (e.g., {"backend.tag": ".auth.image.tag", "frontend.tag": ".frontend.image.tag"})'
        type: string
        required: true
      commit_message_prefix:
        description: 'Prefix for commit message (defaults to repository name if not provided)'
        type: string
        required: false
      runner_type:
        description: 'GitHub runner type to use'
        type: string
        default: 'firmino-lxc-runners'
      enable_argocd_sync:
        description: 'Enable ArgoCD sync after GitOps update'
        type: boolean
        default: true
      argocd_app_name:
        description: 'ArgoCD application name (auto-generated as <server>-<app> if not provided)'
        type: string
        required: false
      use_dynamic_mapping:
        description: 'Use dynamic mapping for multiple components (like midaz)'
        type: boolean
        default: false
      yq_version:
        description: 'Version of yq to install'
        type: string
        default: 'v4.44.3'
      environment_detection:
        description: 'Environment detection strategy: tag_suffix (beta/rc/prd) or manual'
        type: string
        default: 'tag_suffix'
      manual_environment:
        description: 'Manually specify environment (dev/stg/prd/sandbox) - only used if environment_detection is manual'
        type: string
        required: false
      enable_docker_login:
        description: 'Enable Docker Hub login to avoid rate limits'
        type: boolean
        default: true
    secrets:
      manage_token:
        description: 'GitHub token with access to GitOps repository'
        required: true
      ci_cd_user_name:
        description: 'Git user name for commits'
        required: true
      ci_cd_user_email:
        description: 'Git user email for commits'
        required: true
      argocd_token:
        description: 'ArgoCD authentication token (required if enable_argocd_sync is true)'
        required: false
      argocd_url:
        description: 'ArgoCD server URL (required if enable_argocd_sync is true)'
        required: false
      docker_username:
        description: 'Docker Hub username'
        required: true
      docker_password:
        description: 'Docker Hub password'
        required: true

jobs:
  update_gitops:
    runs-on: ${{ inputs.runner_type }}
    steps:
      - name: Log in to Docker Hub
        if: ${{ inputs.enable_docker_login }}
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.docker_username }}
          password: ${{ secrets.docker_password }}

      - name: Checkout GitOps Repository
        uses: actions/checkout@v4
        with:
          repository: ${{ inputs.gitops_repository }}
          token: ${{ secrets.manage_token }}
          path: gitops
          fetch-depth: 0

      - name: Setup application name and paths
        id: setup
        shell: bash
        run: |
          # Extract app name from repository if not provided
          if [[ -z "${{ inputs.app_name }}" ]]; then
            APP_NAME="${GITHUB_REPOSITORY##*/}"
          else
            APP_NAME="${{ inputs.app_name }}"
          fi
          echo "app_name=$APP_NAME" >> "$GITHUB_OUTPUT"
          echo "Application name: $APP_NAME"

          # Generate GitOps file paths if not provided
          SERVER="${{ inputs.gitops_server }}"
          BASE_PATH="gitops/environments/${SERVER}/helmfile/applications"

          if [[ -z "${{ inputs.gitops_file_dev }}" ]]; then
            DEV_FILE="${BASE_PATH}/dev/${APP_NAME}/values.yaml"
          else
            DEV_FILE="${{ inputs.gitops_file_dev }}"
          fi

          if [[ -z "${{ inputs.gitops_file_stg }}" ]]; then
            STG_FILE="${BASE_PATH}/stg/${APP_NAME}/values.yaml"
          else
            STG_FILE="${{ inputs.gitops_file_stg }}"
          fi

          if [[ -z "${{ inputs.gitops_file_prd }}" ]]; then
            PRD_FILE="${BASE_PATH}/prd/${APP_NAME}/values.yaml"
          else
            PRD_FILE="${{ inputs.gitops_file_prd }}"
          fi

          if [[ -z "${{ inputs.gitops_file_sandbox }}" ]]; then
            SANDBOX_FILE="${BASE_PATH}/sandbox/${APP_NAME}/values.yaml"
          else
            SANDBOX_FILE="${{ inputs.gitops_file_sandbox }}"
          fi

          echo "gitops_file_dev=$DEV_FILE" >> "$GITHUB_OUTPUT"
          echo "gitops_file_stg=$STG_FILE" >> "$GITHUB_OUTPUT"
          echo "gitops_file_prd=$PRD_FILE" >> "$GITHUB_OUTPUT"
          echo "gitops_file_sandbox=$SANDBOX_FILE" >> "$GITHUB_OUTPUT"

          # Generate ArgoCD app name if not provided
          if [[ -z "${{ inputs.argocd_app_name }}" ]]; then
            ARGOCD_APP="${SERVER}-${APP_NAME}"
          else
            ARGOCD_APP="${{ inputs.argocd_app_name }}"
          fi
          echo "argocd_app_name=$ARGOCD_APP" >> "$GITHUB_OUTPUT"
          echo "ArgoCD app name: $ARGOCD_APP"

          # Generate commit message prefix if not provided
          if [[ -z "${{ inputs.commit_message_prefix }}" ]]; then
            COMMIT_PREFIX="$APP_NAME"
          else
            COMMIT_PREFIX="${{ inputs.commit_message_prefix }}"
          fi
          echo "commit_prefix=$COMMIT_PREFIX" >> "$GITHUB_OUTPUT"
          echo "Commit message prefix: $COMMIT_PREFIX"

          # Generate artifact pattern if not provided
          if [[ -z "${{ inputs.artifact_pattern }}" ]]; then
            ARTIFACT_PATTERN="gitops-tags-${APP_NAME}-*"
          else
            ARTIFACT_PATTERN="${{ inputs.artifact_pattern }}"
          fi
          echo "artifact_pattern=$ARTIFACT_PATTERN" >> "$GITHUB_OUTPUT"
          echo "Artifact pattern: $ARTIFACT_PATTERN"

      - name: Detect environment from tag
        if: ${{ inputs.environment_detection == 'tag_suffix' }}
        id: detect_env
        shell: bash
        run: |
          TAG_REF="${GITHUB_REF}"
          echo "Processing ref: $TAG_REF"

          if [[ "$TAG_REF" == *"-beta"* ]]; then
            echo "environment=dev" >> "$GITHUB_OUTPUT"
            echo "env_label=beta/dev" >> "$GITHUB_OUTPUT"
            echo "Detected beta tag → dev environment"
          elif [[ "$TAG_REF" == *"-rc"* ]]; then
            echo "environment=stg" >> "$GITHUB_OUTPUT"
            echo "env_label=rc/stg" >> "$GITHUB_OUTPUT"
            echo "Detected rc tag → stg environment"
          elif [[ "$TAG_REF" == refs/tags/* ]] && [[ ! "$TAG_REF" =~ -(beta|rc) ]]; then
            echo "environment=prd" >> "$GITHUB_OUTPUT"
            echo "env_label=production" >> "$GITHUB_OUTPUT"
            echo "Detected production tag → prd environment (will update prd + sandbox)"
          else
            echo "❌ Unable to detect environment from ref: $TAG_REF"
            exit 1
          fi

      - name: Set manual environment
        if: ${{ inputs.environment_detection == 'manual' }}
        id: manual_env
        shell: bash
        run: |
          ENV="${{ inputs.manual_environment }}"
          if [[ -z "$ENV" ]]; then
            echo "❌ manual_environment input is required when environment_detection is 'manual'"
            exit 1
          fi
          echo "environment=$ENV" >> "$GITHUB_OUTPUT"
          echo "env_label=$ENV" >> "$GITHUB_OUTPUT"
          echo "Using manual environment: $ENV"

      - name: Select target values.yaml file
        id: select_file
        shell: bash
        run: |
          set -euo pipefail

          ENV="${{ steps.detect_env.outputs.environment || steps.manual_env.outputs.environment }}"

          case "$ENV" in
            dev)
              FILES="${{ steps.setup.outputs.gitops_file_dev }}"
              ;;
            stg)
              FILES="${{ steps.setup.outputs.gitops_file_stg }}"
              ;;
            prd)
              # Production releases update both prd and sandbox
              PRD_FILE="${{ steps.setup.outputs.gitops_file_prd }}"
              SANDBOX_FILE="${{ steps.setup.outputs.gitops_file_sandbox }}"
              if [[ -n "$PRD_FILE" && -n "$SANDBOX_FILE" ]]; then
                FILES="${PRD_FILE}|${SANDBOX_FILE}"
              elif [[ -n "$PRD_FILE" ]]; then
                FILES="${PRD_FILE}"
              elif [[ -n "$SANDBOX_FILE" ]]; then
                FILES="${SANDBOX_FILE}"
              else
                FILES=""
              fi
              ;;
            *)
              echo "❌ Unknown environment: $ENV"
              exit 1
              ;;
          esac

          if [[ -z "$FILES" ]]; then
            echo "❌ No GitOps file configured for environment: $ENV"
            echo "Please provide gitops_file_${ENV} input"
            exit 1
          fi

          echo "files=$FILES" >> "$GITHUB_OUTPUT"
          echo "Using values files: $FILES for environment: $ENV"

      - name: Install yq
        shell: bash
        run: |
          set -euo pipefail
          YQ_VERSION="${{ inputs.yq_version }}"
          YQ_BIN="yq_linux_amd64"
          YQ_URL="https://github.com/mikefarah/yq/releases/download/${YQ_VERSION}/${YQ_BIN}"

          sudo curl -L "$YQ_URL" -o /usr/local/bin/yq
          sudo chmod +x /usr/local/bin/yq
          yq --version

      - name: Git pull before update
        shell: bash
        run: |
          set -e
          cd gitops
          git pull origin main

      - name: Download artifact tags
        uses: actions/download-artifact@v4
        with:
          pattern: ${{ steps.setup.outputs.artifact_pattern }}
          path: .gitops-tags

      - name: Apply tags to values.yaml (static mapping)
        if: ${{ !inputs.use_dynamic_mapping }}
        shell: bash
        run: |
          set -euo pipefail
          FILES='${{ steps.select_file.outputs.files }}'

          echo "Applying static YAML key mappings..."
          MAPPINGS='${{ inputs.yaml_key_mappings }}'

          # Split files by pipe separator and process each
          IFS='|' read -ra FILE_ARRAY <<< "$FILES"
          for FILE in "${FILE_ARRAY[@]}"; do
            echo "Processing file: $FILE"

            # Parse JSON mappings and apply each one
            echo "$MAPPINGS" | jq -r 'to_entries[] | "\(.key)|\(.value)"' | while IFS='|' read -r artifact_key yaml_key; do
              # Find matching artifact file
              ARTIFACT_FILE=$(find .gitops-tags -type f -name "*${artifact_key}*" | head -n 1)

              if [[ -n "$ARTIFACT_FILE" && -f "$ARTIFACT_FILE" ]]; then
                TAG="$(tr -d '[:space:]' < "$ARTIFACT_FILE")"
                if [[ -n "$TAG" ]]; then
                  echo "  Setting ${yaml_key} → ${TAG} in $FILE"
                  TAG="${TAG}" yq e -i "${yaml_key} = strenv(TAG)" "$FILE"
                else
                  echo "  ⚠️  Empty tag in $ARTIFACT_FILE, skipping"
                fi
              else
                echo "  ⚠️  No artifact found for key: $artifact_key, skipping"
              fi
            done
          done

      - name: Apply tags to values.yaml (dynamic mapping)
        if: ${{ inputs.use_dynamic_mapping }}
        shell: bash
        run: |
          set -euo pipefail
          FILES='${{ steps.select_file.outputs.files }}'

          echo "Applying dynamic YAML key mappings..."

          # Split files by pipe separator and process each
          IFS='|' read -ra FILE_ARRAY <<< "$FILES"
          for FILE in "${FILE_ARRAY[@]}"; do
            echo "Processing file: $FILE"

            # Iterate through all tag artifacts and apply changes dynamically
            find .gitops-tags -type f | while read -r tagfile; do
              filename="$(basename "$tagfile")"

              # Expected format: "app-name=version" (e.g., "midaz-onboarding=1.2.3-rc.1")
              if [[ "$filename" == *"="* ]]; then
                full_app="${filename%%=*}"
                tag="${filename#*=}"

                # Extract component name (remove prefix if configured)
                MAPPINGS='${{ inputs.yaml_key_mappings }}'
                PREFIX=$(echo "$MAPPINGS" | jq -r '.prefix // ""')

                if [[ -n "$PREFIX" ]]; then
                  app_name="${full_app#${PREFIX}}"
                else
                  app_name="$full_app"
                fi

                echo "  Setting .${app_name}.image.tag → ${tag} in $FILE"
                yq e -i ".${app_name}.image.tag = \"${tag}\"" "$FILE"
              else
                echo "  ⚠️  Skipping file with unexpected format: $filename"
              fi
            done
          done

      - name: Show git diff
        shell: bash
        run: |
          cd gitops
          echo "Changes to be committed:"
          FILES='${{ steps.select_file.outputs.files }}'
          IFS='|' read -ra FILE_ARRAY <<< "$FILES"
          for FILE in "${FILE_ARRAY[@]}"; do
            echo "--- Changes in $FILE ---"
            git diff -- "$FILE" || true
          done

      - name: Commit and push GitOps update
        shell: bash
        run: |
          set -e
          cd gitops
          git config user.name "${{ secrets.ci_cd_user_name }}"
          git config user.email "${{ secrets.ci_cd_user_email }}"

          ENV_LABEL="${{ steps.detect_env.outputs.env_label || steps.manual_env.outputs.env_label }}"

          if git diff --quiet; then
            echo "No changes to commit"
          else
            git commit -am "ci(${{ steps.setup.outputs.commit_prefix }}): update image tags (${ENV_LABEL})"
            git push origin main
            echo "✅ GitOps update pushed successfully"
          fi

      - name: ArgoCD Sync (Production)
        if: ${{ inputs.enable_argocd_sync && (steps.detect_env.outputs.environment == 'prd' || steps.manual_env.outputs.environment == 'prd') }}
        uses: LerianStudio/github-actions-argocd-sync@main
        with:
          app-name: ${{ steps.setup.outputs.argocd_app_name }}
          argo-cd-token: ${{ secrets.argocd_token }}
          argo-cd-url: ${{ secrets.argocd_url }}
          env-prefix: prd

      - name: ArgoCD Sync (Sandbox)
        if: ${{ inputs.enable_argocd_sync && (steps.detect_env.outputs.environment == 'prd' || steps.manual_env.outputs.environment == 'prd') }}
        uses: LerianStudio/github-actions-argocd-sync@main
        with:
          app-name: ${{ steps.setup.outputs.argocd_app_name }}
          argo-cd-token: ${{ secrets.argocd_token }}
          argo-cd-url: ${{ secrets.argocd_url }}
          env-prefix: sandbox

      - name: ArgoCD Sync (Dev/Stg)
        if: ${{ inputs.enable_argocd_sync && (steps.detect_env.outputs.environment == 'dev' || steps.detect_env.outputs.environment == 'stg' || steps.manual_env.outputs.environment == 'dev' || steps.manual_env.outputs.environment == 'stg') }}
        uses: LerianStudio/github-actions-argocd-sync@main
        with:
          app-name: ${{ steps.setup.outputs.argocd_app_name }}
          argo-cd-token: ${{ secrets.argocd_token }}
          argo-cd-url: ${{ secrets.argocd_url }}
          env-prefix: ${{ steps.detect_env.outputs.environment || steps.manual_env.outputs.environment }}
