name: "GPT Changelog"

# This reusable workflow generates CHANGELOG.md files using GPTChangelog
# It uses OpenAI GPT-4o to analyze commits and generate human-readable changelogs
#
# Monorepo Support:
# - If filter_paths is provided: detects changes and generates changelog for each changed app
# - If filter_paths is empty: generates changelog for the entire repository (single app mode)
# - Each app gets its own CHANGELOG.md in its folder (best practice for monorepos)
#
# Features:
# - Generates per-app CHANGELOG.md files in each app's folder
# - Updates GitHub Release notes
# - Creates PR with changelog updates using GPG-signed commits
# - Handles tag-based versioning (between tags, first tag, no tags scenarios)
# - Supports stable-only mode (skips beta/rc/alpha tags)

on:
  workflow_call:
    inputs:
      runner_type:
        description: 'Runner to use for the workflow'
        type: string
        default: 'blacksmith'
      filter_paths:
        description: 'Newline-separated list of path prefixes to filter. If not provided, treats as single app repo.'
        type: string
        required: false
        default: ''
      path_level:
        description: 'Limits the path to the first N segments (e.g., 2 -> "charts/agent")'
        type: string
        default: '2'
      stable_releases_only:
        description: 'Only generate changelogs for stable releases (skip beta/rc/alpha tags)'
        type: boolean
        default: true
      openai_model:
        description: 'OpenAI model to use for changelog generation'
        type: string
        default: 'gpt-4o'
      max_context_tokens:
        description: 'Maximum context tokens for OpenAI API'
        type: string
        default: '80000'

permissions:
  contents: write
  pull-requests: write

jobs:
  prepare:
    runs-on: ${{ inputs.runner_type }}
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
      has_changes: ${{ steps.set-matrix.outputs.has_changes }}
      is_stable: ${{ steps.check-tag.outputs.is_stable }}
    steps:
      - name: Checkout for branch check
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check if tag is stable release on main
        id: check-tag
        run: |
          # Detect trigger type: workflow_run or push:tags
          if [[ "$GITHUB_REF" == refs/tags/* ]]; then
            # Triggered by tag push
            TAG_NAME="${GITHUB_REF##*/}"
            echo "üìå Triggered by tag push: $TAG_NAME"
          else
            # Triggered by workflow_run - find latest stable tags
            echo "üìå Triggered by workflow_run, finding latest stable tags..."
            git fetch --tags
            
            # Get tags created in the last hour (recent release)
            LATEST_TAGS=$(git tag --sort=-creatordate | head -20)
            echo "üìå Recent tags: $LATEST_TAGS"
            
            # Find first stable tag (no beta/rc/alpha)
            TAG_NAME=""
            for tag in $LATEST_TAGS; do
              if [[ ! "$tag" =~ -(beta|rc|alpha|dev|snapshot) ]]; then
                TAG_NAME="$tag"
                echo "üìå Found stable tag: $TAG_NAME"
                break
              fi
            done
            
            if [ -z "$TAG_NAME" ]; then
              echo "‚ö†Ô∏è No stable tags found"
              echo "is_stable=false" >> $GITHUB_OUTPUT
              exit 0
            fi
          fi
          
          echo "üìå Processing tag: $TAG_NAME"
          
          # Get the commit SHA for this tag
          TAG_COMMIT=$(git rev-list -n 1 "$TAG_NAME" 2>/dev/null || echo "")
          if [ -z "$TAG_COMMIT" ]; then
            echo "‚ùå Could not find commit for tag: $TAG_NAME"
            echo "is_stable=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          echo "üìå Tag commit: $TAG_COMMIT"
          
          # Check if this commit is on main branch
          DEFAULT_BRANCH=$(gh repo view --json defaultBranchRef -q '.defaultBranchRef.name')
          echo "üìå Default branch: $DEFAULT_BRANCH"
          
          if git merge-base --is-ancestor "$TAG_COMMIT" "origin/$DEFAULT_BRANCH" 2>/dev/null; then
            echo "‚úÖ Tag commit is on $DEFAULT_BRANCH branch"
          else
            echo "‚ùå Tag commit is NOT on $DEFAULT_BRANCH branch - skipping changelog"
            echo "is_stable=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Check if this is a prerelease tag (beta, rc, alpha)
          if [[ "$TAG_NAME" =~ -(beta|rc|alpha|dev|snapshot) ]]; then
            echo "is_stable=false" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è Prerelease tag detected: $TAG_NAME"
            if [ "${{ inputs.stable_releases_only }}" == "true" ]; then
              echo "üõë stable_releases_only=true, skipping changelog generation"
            fi
          else
            echo "is_stable=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Stable release tag on $DEFAULT_BRANCH: $TAG_NAME"
          fi
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Checkout repository
        if: steps.check-tag.outputs.is_stable == 'true' || inputs.stable_releases_only == false
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get changed paths (monorepo)
        if: (steps.check-tag.outputs.is_stable == 'true' || inputs.stable_releases_only == false) && inputs.filter_paths != ''
        id: changed-paths
        uses: LerianStudio/github-actions-changed-paths@main
        with:
          filter_paths: ${{ inputs.filter_paths }}
          path_level: ${{ inputs.path_level }}
          get_app_name: 'true'

      - name: Set matrix
        id: set-matrix
        run: |
          # Skip if stable_releases_only is enabled and tag is not stable
          if [ "${{ inputs.stable_releases_only }}" == "true" ] && [ "${{ steps.check-tag.outputs.is_stable }}" != "true" ]; then
            echo "matrix=[]" >> $GITHUB_OUTPUT
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "üõë Skipping: prerelease tag with stable_releases_only=true"
            exit 0
          fi
          
          # Detect trigger type: workflow_run or push:tags
          if [[ "$GITHUB_REF" != refs/tags/* ]]; then
            # Triggered by workflow_run - find apps from recent stable tags
            echo "üìå Triggered by workflow_run, finding apps from recent stable tags..."
            git fetch --tags
            
            # Get filter_paths as array
            FILTER_PATHS="${{ inputs.filter_paths }}"
            
            if [ -z "$FILTER_PATHS" ]; then
              # Single app mode
              APP_NAME="${{ github.event.repository.name }}"
              echo "matrix=[{\"name\": \"${APP_NAME}\", \"working_dir\": \".\"}]" >> $GITHUB_OUTPUT
              echo "has_changes=true" >> $GITHUB_OUTPUT
              echo "üì¶ Single app mode: ${APP_NAME}"
            else
              # Monorepo mode - find apps with recent stable tags
              MATRIX="["
              FIRST=true
              
              # Parse filter_paths to get app names
              while IFS= read -r path; do
                [ -z "$path" ] && continue
                APP_NAME=$(basename "$path")
                
                # Check if this app has a recent stable tag
                LATEST_TAG=$(git tag --sort=-creatordate | grep "^${APP_NAME}-v" | grep -v -e "-beta" -e "-rc" -e "-alpha" -e "-dev" -e "-snapshot" | head -1)
                
                if [ -n "$LATEST_TAG" ]; then
                  echo "üì¶ Found stable tag for $APP_NAME: $LATEST_TAG"
                  if [ "$FIRST" = true ]; then
                    FIRST=false
                  else
                    MATRIX="$MATRIX,"
                  fi
                  MATRIX="$MATRIX{\"name\": \"${APP_NAME}\", \"working_dir\": \"${path}\"}"
                else
                  echo "‚ö†Ô∏è No stable tag found for $APP_NAME"
                fi
              done <<< "$FILTER_PATHS"
              
              MATRIX="$MATRIX]"
              
              if [ "$MATRIX" = "[]" ]; then
                echo "matrix=[]" >> $GITHUB_OUTPUT
                echo "has_changes=false" >> $GITHUB_OUTPUT
                echo "‚ö†Ô∏è No apps with stable tags found"
              else
                echo "matrix=$MATRIX" >> $GITHUB_OUTPUT
                echo "has_changes=true" >> $GITHUB_OUTPUT
                echo "üì¶ Monorepo mode - found apps: $MATRIX"
              fi
            fi
          else
            # Triggered by tag push - use changed-paths
            if [ -z "${{ inputs.filter_paths }}" ]; then
              # Single app mode - generate changelog from root
              APP_NAME="${{ github.event.repository.name }}"
              echo "matrix=[{\"name\": \"${APP_NAME}\", \"working_dir\": \".\"}]" >> $GITHUB_OUTPUT
              echo "has_changes=true" >> $GITHUB_OUTPUT
              echo "üì¶ Single app mode: ${APP_NAME}"
            else
              MATRIX='${{ steps.changed-paths.outputs.matrix }}'
              if [ "$MATRIX" == "[]" ] || [ -z "$MATRIX" ]; then
                echo "matrix=[]" >> $GITHUB_OUTPUT
                echo "has_changes=false" >> $GITHUB_OUTPUT
                echo "‚ö†Ô∏è No changes detected in filter_paths"
              else
                echo "matrix=$MATRIX" >> $GITHUB_OUTPUT
                echo "has_changes=true" >> $GITHUB_OUTPUT
                echo "üì¶ Monorepo mode - detected changes: $MATRIX"
              fi
            fi
          fi

  generate_changelog:
    needs: prepare
    if: needs.prepare.outputs.has_changes == 'true'
    runs-on: ${{ inputs.runner_type }}
    name: Generate Consolidated Changelog
    outputs:
      sync_pr: ${{ steps.sync.outputs.sync_pr }}

    steps:
      - name: Create GitHub App Token
        uses: actions/create-github-app-token@v1
        id: app-token
        with:
          app-id: ${{ secrets.LERIAN_STUDIO_MIDAZ_PUSH_BOT_APP_ID }}
          private-key: ${{ secrets.LERIAN_STUDIO_MIDAZ_PUSH_BOT_PRIVATE_KEY }}

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ steps.app-token.outputs.token }}

      - name: Sync with remote ref
        run: |
          # Handle both branch and tag triggers
          if [[ "${{ github.ref }}" == refs/tags/* ]]; then
            echo "üìå Triggered by tag: ${{ github.ref_name }}"
            # For tags, checkout already positioned us at the correct commit
            echo "‚úÖ Already at tag commit"
          else
            echo "üìå Triggered by branch: ${{ github.ref_name }}"
            git fetch origin ${{ github.ref_name }}
            git reset --hard origin/${{ github.ref_name }}
          fi

      - name: Import GPG key
        uses: crazy-max/ghaction-import-gpg@v6
        id: import_gpg
        with:
          gpg_private_key: ${{ secrets.LERIAN_CI_CD_USER_GPG_KEY }}
          passphrase: ${{ secrets.LERIAN_CI_CD_USER_GPG_KEY_PASSWORD }}
          git_committer_name: ${{ secrets.LERIAN_CI_CD_USER_NAME }}
          git_committer_email: ${{ secrets.LERIAN_CI_CD_USER_EMAIL }}
          git_config_global: true
          git_user_signingkey: true
          git_commit_gpgsign: true

      - name: Generate changelog for all apps
        id: generate
        run: |
          echo "OPENAI_API_KEY=${OPENAI_API_KEY}" > .env
          git fetch --tags --force
          
          MATRIX='${{ needs.prepare.outputs.matrix }}'
          REPO_URL="https://github.com/${{ github.repository }}"
          
          echo "üì¶ Processing apps from matrix: $MATRIX"
          
          # Initialize files
          > /tmp/apps_updated.txt
          
          # Parse the matrix JSON and iterate through each app
          echo "$MATRIX" | jq -c '.[]' | while read -r APP; do
            APP_NAME=$(echo "$APP" | jq -r '.name')
            WORKING_DIR=$(echo "$APP" | jq -r '.working_dir')
            
            echo ""
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "üìù Processing: $APP_NAME (dir: $WORKING_DIR)"
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            
            # Determine tag pattern based on app type
            if [ "$WORKING_DIR" != "." ]; then
              TAG_PATTERN="${APP_NAME}-v*"
            else
              TAG_PATTERN="v*"
            fi
            
            echo "üîç Looking for tags matching: $TAG_PATTERN"
            
            # Find the latest STABLE tag for this app (exclude beta/rc/alpha)
            LAST_TAG=$(git tag --sort=-version:refname | grep "^${APP_NAME}-v" | grep -v -e "-beta" -e "-rc" -e "-alpha" -e "-dev" -e "-snapshot" | head -1)
            
            if [ -z "$LAST_TAG" ]; then
              echo "‚ö†Ô∏è No stable tag found for $APP_NAME - skipping"
              continue
            fi
            
            echo "üìå Latest stable tag: $LAST_TAG"
            
            # Verify tag exists
            if ! git rev-parse "$LAST_TAG" >/dev/null 2>&1; then
              echo "‚ùå Tag $LAST_TAG does not exist - skipping"
              continue
            fi
            
            # Find previous stable tag for compare link
            PREV_TAG=$(git tag --sort=-version:refname | grep "^${APP_NAME}-v" | grep -v -e "-beta" -e "-rc" -e "-alpha" -e "-dev" -e "-snapshot" | sed -n '2p')
            
            if [ -n "$PREV_TAG" ]; then
              SINCE="$PREV_TAG"
              echo "üü¢ Range: $PREV_TAG ‚Üí $LAST_TAG"
            else
              # First stable release - use first commit
              SINCE=$(git rev-list --max-parents=0 HEAD)
              echo "üü° First stable release - Range: first commit ‚Üí $LAST_TAG"
            fi
            
            # Extract version from tag
            VERSION=$(echo "$LAST_TAG" | sed 's/.*-v//')
            
            # Generate changelog using gptchangelog with path filter
            TEMP_CHANGELOG=$(mktemp)
            TEMP_COMMITS=$(mktemp)
            
            # Get commits that touched this app's path (filtered by path)
            if [ "$WORKING_DIR" != "." ]; then
              git log --oneline "$SINCE".."$LAST_TAG" -- "$WORKING_DIR" > "$TEMP_COMMITS" 2>/dev/null || true
            else
              git log --oneline "$SINCE".."$LAST_TAG" > "$TEMP_COMMITS" 2>/dev/null || true
            fi
            
            COMMIT_COUNT=$(wc -l < "$TEMP_COMMITS" | tr -d ' ')
            echo "üìä Found $COMMIT_COUNT commits for $APP_NAME"
            
            if [ "$COMMIT_COUNT" -eq 0 ]; then
              echo "‚ö†Ô∏è No commits found for $APP_NAME in range - skipping"
              rm -f "$TEMP_CHANGELOG" "$TEMP_COMMITS"
              continue
            fi
            
            # Get detailed commit messages for this app only
            COMMITS_TEXT=$(cat "$TEMP_COMMITS")
            echo "üìù Commits for $APP_NAME:"
            echo "$COMMITS_TEXT"
            
            # Get unique contributors (GitHub usernames) for this app
            # Try to extract GitHub username from email (format: user@users.noreply.github.com or username+id@users.noreply.github.com)
            if [ "$WORKING_DIR" != "." ]; then
              RAW_EMAILS=$(git log "$SINCE".."$LAST_TAG" --format='%ae' -- "$WORKING_DIR" 2>/dev/null | sort -u)
            else
              RAW_EMAILS=$(git log "$SINCE".."$LAST_TAG" --format='%ae' 2>/dev/null | sort -u)
            fi
            
            CONTRIBUTORS=""
            for EMAIL in $RAW_EMAILS; do
              if [[ "$EMAIL" == *"@users.noreply.github.com" ]]; then
                # Extract username from GitHub noreply email
                USERNAME=$(echo "$EMAIL" | sed 's/@users.noreply.github.com//' | sed 's/.*+//')
                CONTRIBUTORS="${CONTRIBUTORS}@${USERNAME}, "
              else
                # Use email prefix as fallback
                USERNAME=$(echo "$EMAIL" | cut -d@ -f1)
                CONTRIBUTORS="${CONTRIBUTORS}@${USERNAME}, "
              fi
            done
            CONTRIBUTORS=$(echo "$CONTRIBUTORS" | sed 's/, $//')
            echo "üë• Contributors: $CONTRIBUTORS"
            
            # Call OpenAI directly with filtered commits (gptchangelog doesn't support path filtering)
            # Build prompt using heredoc to avoid YAML parsing issues
            PROMPT=$(cat <<PROMPT_EOF
Generate a concise changelog for the ${APP_NAME} component based on these commits:

${COMMITS_TEXT}

Requirements:
- Focus ONLY on changes to ${APP_NAME} - do not mention other components
- Use bullet points with brief descriptions
- Group by: Features, Fixes, Improvements (skip empty sections)
- Be specific about what changed in ${APP_NAME}
- Do not use generic descriptions like 'backend' or 'frontend'
- Do not include markdown headers (no ## or ###)
- Start directly with bullet points
- Keep it concise - max 5-6 bullet points
- At the END, add a Contributors section with: ${CONTRIBUTORS}
- Format contributors as GitHub mentions (@username) if possible
PROMPT_EOF
)

            # Escape the prompt for JSON
            ESCAPED_PROMPT=$(echo "$PROMPT" | jq -Rs .)
            
            # Call OpenAI API directly
            RESPONSE=$(curl -s https://api.openai.com/v1/chat/completions \
              -H "Content-Type: application/json" \
              -H "Authorization: Bearer $OPENAI_API_KEY" \
              -d "{
                \"model\": \"${{ inputs.openai_model }}\",
                \"messages\": [{\"role\": \"user\", \"content\": $ESCAPED_PROMPT}],
                \"temperature\": 0.3,
                \"max_tokens\": 1000
              }")
            
            # Extract content from response
            CONTENT=$(echo "$RESPONSE" | jq -r '.choices[0].message.content // empty')
            
            if [ -z "$CONTENT" ]; then
              echo "‚ö†Ô∏è No content generated for $APP_NAME"
              echo "API Response: $RESPONSE"
              rm -f "$TEMP_CHANGELOG" "$TEMP_COMMITS"
              continue
            fi
            
            # Clean up any markdown code blocks
            CONTENT=$(echo "$CONTENT" | sed '/^```/d')
            
            # Determine the changelog path
            if [ "$WORKING_DIR" != "." ]; then
              CHANGELOG_PATH="${WORKING_DIR}/CHANGELOG.md"
            else
              CHANGELOG_PATH="CHANGELOG.md"
            fi
            
            # Build compare link
            if [ -n "$PREV_TAG" ]; then
              COMPARE_LINK="[Compare changes](${REPO_URL}/compare/${PREV_TAG}...${LAST_TAG})"
            else
              COMPARE_LINK="[View all changes](${REPO_URL}/commits/${LAST_TAG})"
            fi
            
            # Create fresh changelog with proper format (no extra --- at top)
            {
              echo "# ${APP_NAME^} Changelog"
              echo ""
              echo "## [${VERSION}](${REPO_URL}/releases/tag/${LAST_TAG})"
              echo ""
              echo "$CONTENT"
              echo ""
              echo "$COMPARE_LINK"
              echo ""
            } > "$CHANGELOG_PATH"
            
            echo "üìÑ Created: $CHANGELOG_PATH"
            
            # Track which apps were updated
            echo "${APP_NAME}:v${VERSION}:${WORKING_DIR}" >> /tmp/apps_updated.txt
            
            # Update GitHub Release notes
            {
              echo "## ${APP_NAME^} v${VERSION}"
              echo ""
              echo "$CONTENT"
              echo ""
              echo "$COMPARE_LINK"
            } > /tmp/app_release_notes.md
            
            gh release edit "$LAST_TAG" --notes-file /tmp/app_release_notes.md || \
              echo "‚ö†Ô∏è Could not update release for $LAST_TAG"
            
            echo "‚úÖ Processed $APP_NAME"
            rm -f "$TEMP_CHANGELOG" "$TEMP_COMMITS"
          done
          
          # Output results
          if [ -s /tmp/apps_updated.txt ]; then
            APPS_LIST=$(cat /tmp/apps_updated.txt 2>/dev/null | cut -d: -f1,2 | tr '\n' ', ' | sed 's/,$//')
            echo "apps_updated=$APPS_LIST" >> $GITHUB_OUTPUT
            echo "‚úÖ Per-app changelogs created for: $APPS_LIST"
          else
            echo "‚ö†Ô∏è No changelog content generated"
            echo "apps_updated=" >> $GITHUB_OUTPUT
          fi
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          GH_TOKEN: ${{ steps.app-token.outputs.token }}

      - name: Show generated changelogs
        run: |
          echo "üìÑ Generated per-app CHANGELOGs:"
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          if [ -f /tmp/apps_updated.txt ]; then
            while IFS=: read -r APP_NAME VERSION WORKING_DIR; do
              if [ "$WORKING_DIR" != "." ]; then
                CHANGELOG_PATH="${WORKING_DIR}/CHANGELOG.md"
              else
                CHANGELOG_PATH="CHANGELOG.md"
              fi
              echo ""
              echo "üì¶ ${APP_NAME} (${CHANGELOG_PATH}):"
              echo "---"
              head -50 "$CHANGELOG_PATH" 2>/dev/null || echo "File not found"
              echo ""
            done < /tmp/apps_updated.txt
          fi
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"

      - name: Create changelog PR
        if: steps.generate.outputs.apps_updated != ''
        run: |
          # Determine base branch - use default branch for tag triggers
          if [[ "${{ github.ref }}" == refs/tags/* ]]; then
            # For tags, get the default branch from the repo
            BASE_BRANCH=$(gh repo view --json defaultBranchRef -q '.defaultBranchRef.name')
            echo "üìå Triggered by tag, using default branch: $BASE_BRANCH"
          else
            BASE_BRANCH="${GITHUB_REF##*/}"
            echo "üìå Triggered by branch: $BASE_BRANCH"
          fi
          
          TIMESTAMP=$(date +%Y%m%d%H%M%S)
          BRANCH_NAME="release/update-changelog-${TIMESTAMP}"
          APPS_UPDATED="${{ steps.generate.outputs.apps_updated }}"
          
          echo "üìå Creating branch: $BRANCH_NAME"
          git checkout -b "$BRANCH_NAME"
          
          # Add all per-app CHANGELOG files
          if [ -f /tmp/apps_updated.txt ]; then
            while IFS=: read -r APP_NAME VERSION WORKING_DIR; do
              if [ "$WORKING_DIR" != "." ]; then
                CHANGELOG_PATH="${WORKING_DIR}/CHANGELOG.md"
              else
                CHANGELOG_PATH="CHANGELOG.md"
              fi
              git add "$CHANGELOG_PATH" 2>/dev/null || true
              echo "üìÑ Added: $CHANGELOG_PATH"
            done < /tmp/apps_updated.txt
          fi
          
          if ! git diff --cached --quiet; then
            git commit -S -m "chore(release): Update CHANGELOGs for ${APPS_UPDATED} [skip ci]"
            echo "‚úÖ CHANGELOGs committed"
          else
            echo "‚ö†Ô∏è No changes to commit"
            exit 0
          fi
          
          # Merge base branch to resolve conflicts
          git fetch origin "$BASE_BRANCH"
          git merge -X ours origin/"$BASE_BRANCH" --no-ff -m "Merge $BASE_BRANCH into ${BRANCH_NAME} [skip ci]" || {
            # Re-add changelog files after conflict resolution
            if [ -f /tmp/apps_updated.txt ]; then
              while IFS=: read -r APP_NAME VERSION WORKING_DIR; do
                if [ "$WORKING_DIR" != "." ]; then
                  CHANGELOG_PATH="${WORKING_DIR}/CHANGELOG.md"
                else
                  CHANGELOG_PATH="CHANGELOG.md"
                fi
                git checkout --ours "$CHANGELOG_PATH" 2>/dev/null || true
                git add "$CHANGELOG_PATH" 2>/dev/null || true
              done < /tmp/apps_updated.txt
            fi
            git commit -m "resolve conflict using ours strategy [skip ci]" || true
          }
          
          # Push and create PR
          git push --force-with-lease origin "$BRANCH_NAME"
          
          if ! gh pr view "$BRANCH_NAME" --base "$BASE_BRANCH" > /dev/null 2>&1; then
            gh pr create \
              --title "chore(release): Update CHANGELOGs [skip ci]" \
              --body "## Automatic Changelog Update

          **Apps Updated:** ${APPS_UPDATED}

          ### Changes
          - Updated per-app CHANGELOG.md files
          - Each changelog generated by GPTChangelog using OpenAI GPT-4o

          ### Apps Included
          $(echo "$APPS_UPDATED" | tr ',' '\n' | sed 's/^/- /')

          ---
          *This PR was automatically generated by the GPTChangelog workflow.*" \
              --base "$BASE_BRANCH" \
              --head "$BRANCH_NAME"
            echo "‚úÖ PR created"
          else
            echo "‚ö†Ô∏è PR already exists"
          fi
          
          # Auto-merge if possible
          gh pr merge --merge --delete-branch || echo "‚ö†Ô∏è Could not auto-merge PR"
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}

      - name: Sync main to develop branch
        id: sync
        if: steps.generate.outputs.apps_updated != ''
        run: |
          DEFAULT_BRANCH=$(gh repo view --json defaultBranchRef -q '.defaultBranchRef.name')
          SYNC_PR_URL=""
          
          # Only sync to develop branch (release-candidate gets updated from develop)
          TARGET_BRANCH="develop"
          
          # Check if develop branch exists
          if ! git ls-remote --heads origin develop | grep -q develop; then
            echo "‚ö†Ô∏è No develop branch found - skipping sync"
            echo "sync_pr=" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "üìå Syncing $DEFAULT_BRANCH ‚Üí $TARGET_BRANCH"
          
          # Check if PR already exists from main to develop
          EXISTING_PR=$(gh pr list --base "$TARGET_BRANCH" --head "$DEFAULT_BRANCH" --json number -q '.[0].number' 2>/dev/null || true)
          if [ -n "$EXISTING_PR" ]; then
            echo "‚ö†Ô∏è PR #$EXISTING_PR already exists for $DEFAULT_BRANCH ‚Üí $TARGET_BRANCH"
            echo "sync_pr=" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Create PR directly from main to develop
          PR_URL=$(gh pr create \
            --title "chore: sync $DEFAULT_BRANCH to $TARGET_BRANCH [skip ci]" \
            --body "## Automatic Changelog Sync

          Syncs changelog updates from \`$DEFAULT_BRANCH\` to \`$TARGET_BRANCH\`.

          **Apps Updated:** ${{ steps.generate.outputs.apps_updated }}

          ---
          *This PR was automatically generated by the GPTChangelog workflow.*
          *Please review and merge manually.*" \
            --base "$TARGET_BRANCH" \
            --head "$DEFAULT_BRANCH" 2>&1) || {
            echo "‚ö†Ô∏è Could not create PR: $PR_URL"
            echo "sync_pr=" >> $GITHUB_OUTPUT
            exit 0
          }
          
          echo "‚úÖ Created PR: $PR_URL"
          echo "sync_pr=$PR_URL" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}

      - name: Cleanup sensitive files
        if: always()
        run: |
          rm -f .env
          rm -f /tmp/apps_updated.txt /tmp/app_release_notes.md
          echo "üßπ Cleaned up sensitive files"

  # Slack notification for workflow status
  notify:
    name: Notify
    needs: [prepare, generate_changelog]
    if: always() && needs.prepare.outputs.has_changes == 'true'
    uses: ./.github/workflows/slack-notify.yml
    with:
      status: ${{ needs.generate_changelog.result }}
      workflow_name: "GPT Changelog"
      failed_jobs: ${{ needs.generate_changelog.result == 'failure' && 'Generate Changelog' || '' }}
    secrets:
      SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  # Notify about sync PR that needs manual review
  notify-sync-pr:
    name: Notify Sync PR
    needs: [generate_changelog]
    if: needs.generate_changelog.result == 'success' && needs.generate_changelog.outputs.sync_pr != ''
    runs-on: ubuntu-latest
    steps:
      - name: Send Slack notification for sync PR
        uses: slackapi/slack-github-action@v1.24.0
        with:
          payload: |
            {
              "blocks": [
                {
                  "type": "header",
                  "text": {
                    "type": "plain_text",
                    "text": "Changelog Sync PR Needs Review",
                    "emoji": true
                  }
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*Repository:* ${{ github.repository }}\n*Triggered by:* ${{ github.ref_name }}\n\nA PR was created to sync changelog updates to develop:"
                  }
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "<${{ needs.generate_changelog.outputs.sync_pr }}|View PR>"
                  }
                },
                {
                  "type": "context",
                  "elements": [
                    {
                      "type": "mrkdwn",
                      "text": "Please review and merge this PR to sync changelog updates to develop branch."
                    }
                  ]
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          SLACK_WEBHOOK_TYPE: INCOMING_WEBHOOK
