name: "GPT Changelog"

# This reusable workflow generates CHANGELOG.md files using GPTChangelog
# It uses OpenAI GPT-4o to analyze commits and generate human-readable changelogs
#
# Monorepo Support:
# - If filter_paths is provided: detects changes and generates changelog for each changed app
# - If filter_paths is empty: generates changelog for the entire repository (single app mode)
# - Each app gets its own CHANGELOG.md in its folder (best practice for monorepos)
#
# Features:
# - Generates per-app CHANGELOG.md files in each app's folder
# - Updates GitHub Release notes
# - Creates PR with changelog updates using GPG-signed commits
# - Handles tag-based versioning (between tags, first tag, no tags scenarios)
# - Supports stable-only mode (skips beta/rc/alpha tags)

on:
  workflow_call:
    inputs:
      runner_type:
        description: 'Runner to use for the workflow'
        type: string
        default: 'blacksmith'
      filter_paths:
        description: 'Newline-separated list of path prefixes to filter. If not provided, treats as single app repo.'
        type: string
        required: false
        default: ''
      path_level:
        description: 'Limits the path to the first N segments (e.g., 2 -> "charts/agent")'
        type: string
        default: '2'
      stable_releases_only:
        description: 'Only generate changelogs for stable releases (skip beta/rc/alpha tags)'
        type: boolean
        default: true
      openai_model:
        description: 'OpenAI model to use for changelog generation'
        type: string
        default: 'gpt-4o'
      max_context_tokens:
        description: 'Maximum context tokens for OpenAI API'
        type: string
        default: '80000'
      python_version:
        description: 'Python version to use'
        type: string
        default: '3.10'

permissions:
  contents: write
  pull-requests: write

jobs:
  prepare:
    runs-on: ${{ inputs.runner_type }}
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
      has_changes: ${{ steps.set-matrix.outputs.has_changes }}
      is_stable: ${{ steps.check-tag.outputs.is_stable }}
    steps:
      - name: Checkout for branch check
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check if tag is stable release on main
        id: check-tag
        run: |
          TAG_NAME="${GITHUB_REF##*/}"
          echo "üìå Checking tag: $TAG_NAME"
          
          # Get the commit SHA for this tag
          TAG_COMMIT=$(git rev-list -n 1 "$TAG_NAME" 2>/dev/null || echo "")
          if [ -z "$TAG_COMMIT" ]; then
            echo "‚ùå Could not find commit for tag: $TAG_NAME"
            echo "is_stable=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          echo "üìå Tag commit: $TAG_COMMIT"
          
          # Check if this commit is on main branch
          DEFAULT_BRANCH=$(gh repo view --json defaultBranchRef -q '.defaultBranchRef.name')
          echo "üìå Default branch: $DEFAULT_BRANCH"
          
          if git merge-base --is-ancestor "$TAG_COMMIT" "origin/$DEFAULT_BRANCH" 2>/dev/null; then
            echo "‚úÖ Tag commit is on $DEFAULT_BRANCH branch"
          else
            echo "‚ùå Tag commit is NOT on $DEFAULT_BRANCH branch - skipping changelog"
            echo "is_stable=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Check if this is a prerelease tag (beta, rc, alpha)
          if [[ "$TAG_NAME" =~ -(beta|rc|alpha|dev|snapshot) ]]; then
            echo "is_stable=false" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è Prerelease tag detected: $TAG_NAME"
            if [ "${{ inputs.stable_releases_only }}" == "true" ]; then
              echo "üõë stable_releases_only=true, skipping changelog generation"
            fi
          else
            echo "is_stable=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Stable release tag on $DEFAULT_BRANCH: $TAG_NAME"
          fi
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Checkout repository
        if: steps.check-tag.outputs.is_stable == 'true' || inputs.stable_releases_only == false
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get changed paths (monorepo)
        if: (steps.check-tag.outputs.is_stable == 'true' || inputs.stable_releases_only == false) && inputs.filter_paths != ''
        id: changed-paths
        uses: LerianStudio/github-actions-changed-paths@main
        with:
          filter_paths: ${{ inputs.filter_paths }}
          path_level: ${{ inputs.path_level }}
          get_app_name: 'true'

      - name: Set matrix
        id: set-matrix
        run: |
          # Skip if stable_releases_only is enabled and tag is not stable
          if [ "${{ inputs.stable_releases_only }}" == "true" ] && [ "${{ steps.check-tag.outputs.is_stable }}" != "true" ]; then
            echo "matrix=[]" >> $GITHUB_OUTPUT
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "üõë Skipping: prerelease tag with stable_releases_only=true"
            exit 0
          fi
          
          if [ -z "${{ inputs.filter_paths }}" ]; then
            # Single app mode - generate changelog from root
            APP_NAME="${{ github.event.repository.name }}"
            echo "matrix=[{\"name\": \"${APP_NAME}\", \"working_dir\": \".\"}]" >> $GITHUB_OUTPUT
            echo "has_changes=true" >> $GITHUB_OUTPUT
            echo "üì¶ Single app mode: ${APP_NAME}"
          else
            MATRIX='${{ steps.changed-paths.outputs.matrix }}'
            if [ "$MATRIX" == "[]" ] || [ -z "$MATRIX" ]; then
              echo "matrix=[]" >> $GITHUB_OUTPUT
              echo "has_changes=false" >> $GITHUB_OUTPUT
              echo "‚ö†Ô∏è No changes detected in filter_paths"
            else
              echo "matrix=$MATRIX" >> $GITHUB_OUTPUT
              echo "has_changes=true" >> $GITHUB_OUTPUT
              echo "üì¶ Monorepo mode - detected changes: $MATRIX"
            fi
          fi

  generate_changelog:
    needs: prepare
    if: needs.prepare.outputs.has_changes == 'true'
    runs-on: ${{ inputs.runner_type }}
    name: Generate Consolidated Changelog
    outputs:
      sync_prs: ${{ steps.sync.outputs.sync_prs }}

    steps:
      - name: Create GitHub App Token
        uses: actions/create-github-app-token@v1
        id: app-token
        with:
          app-id: ${{ secrets.LERIAN_STUDIO_MIDAZ_PUSH_BOT_APP_ID }}
          private-key: ${{ secrets.LERIAN_STUDIO_MIDAZ_PUSH_BOT_PRIVATE_KEY }}

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ steps.app-token.outputs.token }}

      - name: Sync with remote ref
        run: |
          # Handle both branch and tag triggers
          if [[ "${{ github.ref }}" == refs/tags/* ]]; then
            echo "üìå Triggered by tag: ${{ github.ref_name }}"
            # For tags, checkout already positioned us at the correct commit
            echo "‚úÖ Already at tag commit"
          else
            echo "üìå Triggered by branch: ${{ github.ref_name }}"
            git fetch origin ${{ github.ref_name }}
            git reset --hard origin/${{ github.ref_name }}
          fi

      - name: Import GPG key
        uses: crazy-max/ghaction-import-gpg@v6
        id: import_gpg
        with:
          gpg_private_key: ${{ secrets.LERIAN_CI_CD_USER_GPG_KEY }}
          passphrase: ${{ secrets.LERIAN_CI_CD_USER_GPG_KEY_PASSWORD }}
          git_committer_name: ${{ secrets.LERIAN_CI_CD_USER_NAME }}
          git_committer_email: ${{ secrets.LERIAN_CI_CD_USER_EMAIL }}
          git_config_global: true
          git_user_signingkey: true
          git_commit_gpgsign: true

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ inputs.python_version }}

      - name: Install gptchangelog
        run: |
          python -m pip install --upgrade pip
          pip install gptchangelog
          echo "‚úÖ gptchangelog installed successfully"

      - name: Create gptchangelog config
        run: |
          # Initialize config first (creates proper structure)
          # Note: gptchangelog config init may prompt for input, so we skip it and create config manually
          
          # Create project-specific config
          mkdir -p .gptchangelog
          echo "[gptchangelog]" > .gptchangelog/config.ini
          echo "openai = true" >> .gptchangelog/config.ini
          echo "" >> .gptchangelog/config.ini
          echo "[openai]" >> .gptchangelog/config.ini
          echo "api_key = ${OPENAI_API_KEY}" >> .gptchangelog/config.ini
          echo "model = ${{ inputs.openai_model }}" >> .gptchangelog/config.ini
          echo "max_context_tokens = ${{ inputs.max_context_tokens }}" >> .gptchangelog/config.ini
          
          # Also create global config as fallback
          mkdir -p ~/.config/gptchangelog
          cp .gptchangelog/config.ini ~/.config/gptchangelog/config.ini
          
          echo "‚úÖ gptchangelog config created"
          echo "üìÑ Config contents:"
          cat .gptchangelog/config.ini | grep -v api_key
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}

      - name: Create changelog prompt template
        run: |
          mkdir -p .gptchangelog/templates
          cat > .gptchangelog/templates/changelog_prompt.txt << 'EOF'
          ## Release $next_version

          ### What's New
          $commit_messages

          ### ‚ú® Features
          - Highlight new features added in this release.

          ### üõ† Fixes
          - List bug fixes and improvements.

          ### üìö Documentation
          - Summarize updates to documentation.

          ### üöÄ Improvements
          - Highlight performance or backend optimizations.

          ### ‚ö†Ô∏è Breaking Changes
          - List any breaking changes here.

          ### üôå Contributors
          - Acknowledge contributors for this release.
          EOF
          echo "‚úÖ Changelog prompt template created"

      - name: Generate consolidated changelog for all apps
        id: generate
        run: |
          echo "OPENAI_API_KEY=${OPENAI_API_KEY}" > .env
          git fetch --tags --force
          
          MATRIX='${{ needs.prepare.outputs.matrix }}'
          
          echo "üì¶ Processing apps from matrix: $MATRIX"
          
          # Initialize files
          > /tmp/consolidated_changelog.md
          > /tmp/consolidated_release_notes.md
          > /tmp/apps_updated.txt
          
          # Parse the matrix JSON and iterate through each app
          echo "$MATRIX" | jq -c '.[]' | while read -r APP; do
            APP_NAME=$(echo "$APP" | jq -r '.name')
            WORKING_DIR=$(echo "$APP" | jq -r '.working_dir')
            
            echo ""
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "üìù Processing: $APP_NAME (dir: $WORKING_DIR)"
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            
            # Determine tag pattern based on app type
            if [ "$WORKING_DIR" != "." ]; then
              TAG_PATTERN="${APP_NAME}-v*"
            else
              TAG_PATTERN="v*"
            fi
            
            echo "üîç Looking for tags matching: $TAG_PATTERN"
            
            # Determine version range
            if git describe --tags --abbrev=0 --match "$TAG_PATTERN" HEAD >/dev/null 2>&1; then
              LAST_TAG=$(git describe --tags --abbrev=0 --match "$TAG_PATTERN" HEAD)
              
              if git describe --tags --abbrev=0 --match "$TAG_PATTERN" HEAD^ >/dev/null 2>&1; then
                PENULT_TAG=$(git describe --tags --abbrev=0 --match "$TAG_PATTERN" HEAD^)
                SINCE="$PENULT_TAG"
                TO="$LAST_TAG"
                echo "üü¢ Range: $PENULT_TAG ‚Üí $LAST_TAG"
              else
                FIRST_COMMIT=$(git rev-list --max-parents=0 HEAD)
                SINCE="$FIRST_COMMIT"
                TO="$LAST_TAG"
                echo "üü° First tag - Range: $FIRST_COMMIT ‚Üí $LAST_TAG"
              fi
            else
              FIRST_COMMIT=$(git rev-list --max-parents=0 HEAD)
              SINCE="$FIRST_COMMIT"
              TO="HEAD"
              LAST_TAG="HEAD"
              echo "üî¥ No tags - Range: $FIRST_COMMIT ‚Üí HEAD"
            fi
            
            # Extract version from tag
            VERSION=$(echo "$LAST_TAG" | sed 's/.*-v/v/' | sed 's/^v//')
            
            # Extract previous version for compare link
            if [ -n "$PENULT_TAG" ]; then
              PREV_VERSION=$(echo "$PENULT_TAG" | sed 's/.*-v/v/' | sed 's/^v//')
            else
              PREV_VERSION="initial"
            fi
            
            # Generate changelog for this app (run from repo root, gptchangelog needs git access)
            TEMP_CHANGELOG=$(mktemp)
            
            if gptchangelog generate --since "$SINCE" --to "$TO" --output "$TEMP_CHANGELOG"; then
              # Clean up markdown blocks
              sed -i '' '/^```/d' "$TEMP_CHANGELOG" 2>/dev/null || sed -i '/^```/d' "$TEMP_CHANGELOG"
              
              # Extract content (skip the header line if present)
              CONTENT=$(cat "$TEMP_CHANGELOG" | tail -n +2)
              
              # Determine the changelog path (per-app folder or root)
              if [ "$WORKING_DIR" != "." ]; then
                CHANGELOG_PATH="${WORKING_DIR}/CHANGELOG.md"
              else
                CHANGELOG_PATH="CHANGELOG.md"
              fi
              
              # Prepare the new changelog entry for this app
              # Get repo URL for links
              REPO_URL="https://github.com/${{ github.repository }}"
              TAG_NAME="${APP_NAME}-v${VERSION}"
              
              cat > /tmp/new_entry.md << ENTRY_EOF
---

## [${VERSION}](${REPO_URL}/releases/tag/${TAG_NAME})

${CONTENT}

[Compare changes](${REPO_URL}/compare/${APP_NAME}-v${PREV_VERSION}...${TAG_NAME})

ENTRY_EOF
              
              # Update or create per-app CHANGELOG.md
              if [ -f "$CHANGELOG_PATH" ]; then
                # Insert after the title line
                if grep -q "^# " "$CHANGELOG_PATH"; then
                  TITLE=$(head -n 1 "$CHANGELOG_PATH")
                  EXISTING=$(tail -n +2 "$CHANGELOG_PATH")
                  echo "$TITLE" > "$CHANGELOG_PATH"
                  echo "" >> "$CHANGELOG_PATH"
                  cat /tmp/new_entry.md >> "$CHANGELOG_PATH"
                  echo "$EXISTING" >> "$CHANGELOG_PATH"
                else
                  cat /tmp/new_entry.md > /tmp/new_changelog.md
                  cat "$CHANGELOG_PATH" >> /tmp/new_changelog.md
                  mv /tmp/new_changelog.md "$CHANGELOG_PATH"
                fi
              else
                echo "# ${APP_NAME} Changelog" > "$CHANGELOG_PATH"
                echo "" >> "$CHANGELOG_PATH"
                cat /tmp/new_entry.md >> "$CHANGELOG_PATH"
              fi
              
              echo "üìÑ Updated: $CHANGELOG_PATH"
              
              # Track which apps were updated (with their paths)
              echo "${APP_NAME}:v${VERSION}:${WORKING_DIR}" >> /tmp/apps_updated.txt
              
              # Update GitHub Release for this app's tag (if not HEAD)
              if [ "$LAST_TAG" != "HEAD" ]; then
                echo "## ${APP_NAME} v${VERSION}" > /tmp/app_release_notes.md
                echo "" >> /tmp/app_release_notes.md
                echo "$CONTENT" >> /tmp/app_release_notes.md
                gh release edit "$LAST_TAG" --notes-file /tmp/app_release_notes.md || \
                  echo "‚ö†Ô∏è Could not update release for $LAST_TAG"
              fi
              
              echo "‚úÖ Processed $APP_NAME"
            else
              echo "‚ö†Ô∏è Failed to generate changelog for $APP_NAME"
            fi
            
            rm -f "$TEMP_CHANGELOG"
          done
          
          # Output results
          if [ -s /tmp/apps_updated.txt ]; then
            APPS_LIST=$(cat /tmp/apps_updated.txt 2>/dev/null | cut -d: -f1,2 | tr '\n' ', ' | sed 's/,$//')
            echo "apps_updated=$APPS_LIST" >> $GITHUB_OUTPUT
            echo "‚úÖ Per-app changelogs created for: $APPS_LIST"
          else
            echo "‚ö†Ô∏è No changelog content generated"
            echo "apps_updated=" >> $GITHUB_OUTPUT
          fi
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          GH_TOKEN: ${{ steps.app-token.outputs.token }}

      - name: Show generated changelogs
        run: |
          echo "üìÑ Generated per-app CHANGELOGs:"
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          if [ -f /tmp/apps_updated.txt ]; then
            while IFS=: read -r APP_NAME VERSION WORKING_DIR; do
              if [ "$WORKING_DIR" != "." ]; then
                CHANGELOG_PATH="${WORKING_DIR}/CHANGELOG.md"
              else
                CHANGELOG_PATH="CHANGELOG.md"
              fi
              echo ""
              echo "üì¶ ${APP_NAME} (${CHANGELOG_PATH}):"
              echo "---"
              head -50 "$CHANGELOG_PATH" 2>/dev/null || echo "File not found"
              echo ""
            done < /tmp/apps_updated.txt
          fi
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"

      - name: Create changelog PR
        if: steps.generate.outputs.apps_updated != ''
        run: |
          # Determine base branch - use default branch for tag triggers
          if [[ "${{ github.ref }}" == refs/tags/* ]]; then
            # For tags, get the default branch from the repo
            BASE_BRANCH=$(gh repo view --json defaultBranchRef -q '.defaultBranchRef.name')
            echo "üìå Triggered by tag, using default branch: $BASE_BRANCH"
          else
            BASE_BRANCH="${GITHUB_REF##*/}"
            echo "üìå Triggered by branch: $BASE_BRANCH"
          fi
          
          TIMESTAMP=$(date +%Y%m%d%H%M%S)
          BRANCH_NAME="release/update-changelog-${TIMESTAMP}"
          APPS_UPDATED="${{ steps.generate.outputs.apps_updated }}"
          
          echo "üìå Creating branch: $BRANCH_NAME"
          git checkout -b "$BRANCH_NAME"
          
          # Add all per-app CHANGELOG files
          if [ -f /tmp/apps_updated.txt ]; then
            while IFS=: read -r APP_NAME VERSION WORKING_DIR; do
              if [ "$WORKING_DIR" != "." ]; then
                CHANGELOG_PATH="${WORKING_DIR}/CHANGELOG.md"
              else
                CHANGELOG_PATH="CHANGELOG.md"
              fi
              git add "$CHANGELOG_PATH" 2>/dev/null || true
              echo "üìÑ Added: $CHANGELOG_PATH"
            done < /tmp/apps_updated.txt
          fi
          
          if ! git diff --cached --quiet; then
            git commit -S -m "chore(release): Update CHANGELOGs for ${APPS_UPDATED} [skip ci]"
            echo "‚úÖ CHANGELOGs committed"
          else
            echo "‚ö†Ô∏è No changes to commit"
            exit 0
          fi
          
          # Merge base branch to resolve conflicts
          git fetch origin "$BASE_BRANCH"
          git merge -X ours origin/"$BASE_BRANCH" --no-ff -m "Merge $BASE_BRANCH into ${BRANCH_NAME} [skip ci]" || {
            # Re-add changelog files after conflict resolution
            if [ -f /tmp/apps_updated.txt ]; then
              while IFS=: read -r APP_NAME VERSION WORKING_DIR; do
                if [ "$WORKING_DIR" != "." ]; then
                  CHANGELOG_PATH="${WORKING_DIR}/CHANGELOG.md"
                else
                  CHANGELOG_PATH="CHANGELOG.md"
                fi
                git checkout --ours "$CHANGELOG_PATH" 2>/dev/null || true
                git add "$CHANGELOG_PATH" 2>/dev/null || true
              done < /tmp/apps_updated.txt
            fi
            git commit -m "resolve conflict using ours strategy [skip ci]" || true
          }
          
          # Push and create PR
          git push --force-with-lease origin "$BRANCH_NAME"
          
          if ! gh pr view "$BRANCH_NAME" --base "$BASE_BRANCH" > /dev/null 2>&1; then
            gh pr create \
              --title "chore(release): Update CHANGELOGs [skip ci]" \
              --body "## Automatic Changelog Update

          **Apps Updated:** ${APPS_UPDATED}

          ### Changes
          - Updated per-app CHANGELOG.md files
          - Each changelog generated by GPTChangelog using OpenAI GPT-4o

          ### Apps Included
          $(echo "$APPS_UPDATED" | tr ',' '\n' | sed 's/^/- /')

          ---
          *This PR was automatically generated by the GPTChangelog workflow.*" \
              --base "$BASE_BRANCH" \
              --head "$BRANCH_NAME"
            echo "‚úÖ PR created"
          else
            echo "‚ö†Ô∏è PR already exists"
          fi
          
          # Auto-merge if possible
          gh pr merge --merge --delete-branch || echo "‚ö†Ô∏è Could not auto-merge PR"
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}

      - name: Sync main to develop and RC branches
        id: sync
        if: steps.generate.outputs.apps_updated != ''
        run: |
          DEFAULT_BRANCH=$(gh repo view --json defaultBranchRef -q '.defaultBranchRef.name')
          SYNC_PRS=""
          
          # List of branches to sync to
          SYNC_TARGETS=""
          
          # Check if develop branch exists
          if git ls-remote --heads origin develop | grep -q develop; then
            SYNC_TARGETS="develop"
            echo "‚úÖ Found develop branch"
          fi
          
          # Check if release-candidate branch exists
          if git ls-remote --heads origin release-candidate | grep -q release-candidate; then
            SYNC_TARGETS="$SYNC_TARGETS release-candidate"
            echo "‚úÖ Found release-candidate branch"
          fi
          
          if [ -z "$SYNC_TARGETS" ]; then
            echo "‚ö†Ô∏è No sync target branches found (develop, release-candidate)"
            exit 0
          fi
          
          echo "üìå Will sync $DEFAULT_BRANCH to: $SYNC_TARGETS"
          
          for TARGET_BRANCH in $SYNC_TARGETS; do
            echo ""
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "üìå Syncing $DEFAULT_BRANCH ‚Üí $TARGET_BRANCH"
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            
            # Check if PR already exists from main to this target
            EXISTING_PR=$(gh pr list --base "$TARGET_BRANCH" --head "$DEFAULT_BRANCH" --json number -q '.[0].number' 2>/dev/null || true)
            if [ -n "$EXISTING_PR" ]; then
              echo "‚ö†Ô∏è PR #$EXISTING_PR already exists for $DEFAULT_BRANCH ‚Üí $TARGET_BRANCH"
              continue
            fi
            
            # Create PR directly from main to target (no intermediate branch)
            PR_URL=$(gh pr create \
              --title "chore: sync $DEFAULT_BRANCH to $TARGET_BRANCH [skip ci]" \
              --body "## Automatic Changelog Sync

          Syncs changelog updates from \`$DEFAULT_BRANCH\` to \`$TARGET_BRANCH\`.

          **Apps Updated:** ${{ steps.generate.outputs.apps_updated }}

          ---
          *This PR was automatically generated by the GPTChangelog workflow.*
          *Please review and merge manually.*" \
              --base "$TARGET_BRANCH" \
              --head "$DEFAULT_BRANCH" 2>&1) || {
              echo "‚ö†Ô∏è Could not create PR for $TARGET_BRANCH: $PR_URL"
              continue
            }
            
            echo "‚úÖ Created PR: $PR_URL"
            SYNC_PRS="${SYNC_PRS}${PR_URL}\n"
          done
          
          # Output PR URLs for Slack notification
          echo "sync_prs<<EOF" >> $GITHUB_OUTPUT
          echo -e "$SYNC_PRS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}

      - name: Cleanup sensitive files
        if: always()
        run: |
          rm -f .env
          rm -rf .gptchangelog
          rm -f /tmp/consolidated_changelog.md /tmp/consolidated_release_notes.md /tmp/apps_updated.txt /tmp/app_release_notes.md /tmp/new_entry.md
          echo "üßπ Cleaned up sensitive files"

  # Slack notification for workflow status
  notify:
    name: Notify
    needs: [prepare, generate_changelog]
    if: always() && needs.prepare.outputs.has_changes == 'true'
    uses: ./.github/workflows/slack-notify.yml
    with:
      status: ${{ needs.generate_changelog.result }}
      workflow_name: "GPT Changelog"
      failed_jobs: ${{ needs.generate_changelog.result == 'failure' && 'Generate Changelog' || '' }}
    secrets:
      SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  # Notify about sync PRs that need manual review
  notify-sync-prs:
    name: Notify Sync PRs
    needs: [generate_changelog]
    if: needs.generate_changelog.result == 'success'
    runs-on: ubuntu-latest
    steps:
      - name: Send Slack notification for sync PRs
        if: needs.generate_changelog.outputs.sync_prs != ''
        uses: slackapi/slack-github-action@v1.24.0
        with:
          payload: |
            {
              "blocks": [
                {
                  "type": "header",
                  "text": {
                    "type": "plain_text",
                    "text": "üìã Changelog Sync PRs Need Review",
                    "emoji": true
                  }
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*Repository:* ${{ github.repository }}\n*Triggered by:* ${{ github.ref_name }}\n\nThe following PRs were created to sync changelog updates and need manual review:"
                  }
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "${{ needs.generate_changelog.outputs.sync_prs }}"
                  }
                },
                {
                  "type": "context",
                  "elements": [
                    {
                      "type": "mrkdwn",
                      "text": "Please review and merge these PRs to sync changelog updates to develop and RC branches."
                    }
                  ]
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          SLACK_WEBHOOK_TYPE: INCOMING_WEBHOOK
