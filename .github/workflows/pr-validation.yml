name: "PR Validation"

# Reusable workflow for comprehensive pull request validation
# Checks PR title, size, description, labels, and best practices

on:
  workflow_call:
    inputs:
      runner_type:
        description: 'GitHub runner type to use'
        type: string
        default: 'ubuntu-latest'
      pr_title_types:
        description: 'Allowed commit types (pipe-separated)'
        type: string
        default: |
          feat
          fix
          docs
          style
          refactor
          perf
          test
          chore
          ci
          build
          revert
      pr_title_scopes:
        description: 'Allowed scopes (pipe-separated, empty = any scope allowed)'
        type: string
        default: ''
      require_scope:
        description: 'Require scope in PR title'
        type: boolean
        default: false
      min_description_length:
        description: 'Minimum PR description length'
        type: number
        default: 50
      check_changelog:
        description: 'Check if CHANGELOG.md is updated'
        type: boolean
        default: true
      enable_auto_labeler:
        description: 'Enable automatic labeling based on changed files'
        type: boolean
        default: true
      labeler_config_path:
        description: 'Path to labeler configuration file'
        type: string
        default: '.github/labeler.yml'
      enforce_source_branches:
        description: 'Enforce that PRs to protected branches come from specific source branches'
        type: boolean
        default: false
      allowed_source_branches:
        description: 'Allowed source branches for PRs to protected branches (pipe-separated, supports prefix matching with *)'
        type: string
        default: 'develop|release-candidate|hotfix/*'
      target_branches_for_source_check:
        description: 'Target branches that require source branch validation (pipe-separated)'
        type: string
        default: 'main'

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  skip-if-draft:
    name: Skip if Draft
    runs-on: ${{ inputs.runner_type }}
    outputs:
      should_skip: ${{ steps.check.outputs.should_skip }}
    steps:
      - name: Check if draft
        id: check
        run: |
          if [ "${{ github.event.pull_request.draft }}" = "true" ]; then
            echo "should_skip=true" >> $GITHUB_OUTPUT
          else
            echo "should_skip=false" >> $GITHUB_OUTPUT
          fi

  pr-source-branch:
    name: Validate Source Branch
    runs-on: ${{ inputs.runner_type }}
    needs: skip-if-draft
    if: needs.skip-if-draft.outputs.should_skip != 'true' && inputs.enforce_source_branches

    steps:
      - name: Check source branch
        id: check_branch
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.MANAGE_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const sourceBranch = context.payload.pull_request.head.ref;
            const targetBranch = context.payload.pull_request.base.ref;
            const allowedBranches = '${{ inputs.allowed_source_branches }}'.split('|').map(b => b.trim());
            const targetBranchesForCheck = '${{ inputs.target_branches_for_source_check }}'.split('|').map(b => b.trim());

            // Check if this target branch requires source validation
            if (!targetBranchesForCheck.includes(targetBranch)) {
              console.log(`Target branch '${targetBranch}' does not require source branch validation`);
              return;
            }

            console.log(`Checking if source branch '${sourceBranch}' is allowed for target '${targetBranch}'`);
            console.log(`Allowed patterns: ${allowedBranches.join(', ')}`);

            // Check if source branch matches any allowed pattern
            let isAllowed = false;
            for (const pattern of allowedBranches) {
              if (pattern.endsWith('/*')) {
                // Prefix match (e.g., hotfix/*)
                const prefix = pattern.slice(0, -1);
                if (sourceBranch.startsWith(prefix)) {
                  isAllowed = true;
                  break;
                }
              } else if (pattern === sourceBranch) {
                // Exact match
                isAllowed = true;
                break;
              }
            }

            if (!isAllowed) {
              // Add REQUEST_CHANGES review
              const message = `⚠️ **Invalid Source Branch**\n\nPull requests to **${targetBranch}** can only come from:\n${allowedBranches.map(b => `- \`${b}\``).join('\n')}\n\nYour source branch: \`${sourceBranch}\`\n\nPlease **change the base branch** or create a PR from an allowed branch.`;

              await github.rest.pulls.createReview({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.issue.number,
                body: message,
                event: 'REQUEST_CHANGES'
              });

              core.setFailed(`Source branch '${sourceBranch}' is not allowed for PRs to '${targetBranch}'`);
            } else {
              console.log(`✅ Source branch '${sourceBranch}' is allowed`);
            }

  pr-title:
    name: Validate PR Title
    runs-on: ${{ inputs.runner_type }}
    needs: skip-if-draft
    if: needs.skip-if-draft.outputs.should_skip != 'true'

    steps:
      - name: Check PR title format
        uses: amannn/action-semantic-pull-request@v5
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          types: ${{ inputs.pr_title_types }}
          scopes: ${{ inputs.pr_title_scopes }}
          requireScope: ${{ inputs.require_scope }}
          subjectPattern: ^[a-z].+$
          subjectPatternError: |
            The subject "{subject}" found in the pull request title "{title}"
            didn't match the configured pattern. Please ensure that the subject
            starts with a lowercase character.

  pr-size:
    name: Check PR Size
    runs-on: ${{ inputs.runner_type }}
    needs: skip-if-draft
    if: needs.skip-if-draft.outputs.should_skip != 'true'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check PR size
        id: size
        run: |
          # Get changed lines
          CHANGED_LINES=$(git diff --shortstat origin/${{ github.base_ref }}...HEAD | \
            awk '{print $4+$6}')
          echo "changed_lines=$CHANGED_LINES" >> $GITHUB_OUTPUT

          # Set size label
          if [ "$CHANGED_LINES" -lt 50 ]; then
            SIZE="XS"
          elif [ "$CHANGED_LINES" -lt 200 ]; then
            SIZE="S"
          elif [ "$CHANGED_LINES" -lt 500 ]; then
            SIZE="M"
          elif [ "$CHANGED_LINES" -lt 1000 ]; then
            SIZE="L"
          else
            SIZE="XL"
          fi
          echo "size=$SIZE" >> $GITHUB_OUTPUT

      - name: Add size label
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.MANAGE_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const size = '${{ steps.size.outputs.size }}';
            const labels = ['size/XS', 'size/S', 'size/M', 'size/L', 'size/XL'];

            // Remove existing size labels
            for (const label of labels) {
              try {
                await github.rest.issues.removeLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  name: label
                });
              } catch (error) {
                // Label doesn't exist, ignore
              }
            }

            // Add new size label
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              labels: [`size/${size}`]
            });

      - name: Comment on large PR
        if: steps.size.outputs.size == 'XL'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.MANAGE_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `This PR is very large (${context.payload.pull_request.changed_files} files, ${{ steps.size.outputs.changed_lines }} lines changed). Consider breaking it into smaller PRs for easier review.`
            });

  pr-description:
    name: Check PR Description
    runs-on: ${{ inputs.runner_type }}
    needs: skip-if-draft
    if: needs.skip-if-draft.outputs.should_skip != 'true'

    steps:
      - name: Check description length
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.MANAGE_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const body = context.payload.pull_request.body || '';
            const minLength = ${{ inputs.min_description_length }};

            if (body.length < minLength) {
              core.setFailed(`PR description is too short (${body.length} chars). Please provide a detailed description (minimum ${minLength} chars).`);
            }

      - name: Check for required sections
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.MANAGE_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const body = context.payload.pull_request.body || '';
            const requiredSections = ['Description', 'Type of Change'];
            const missingSections = [];

            for (const section of requiredSections) {
              if (!body.includes(section)) {
                missingSections.push(section);
              }
            }

            if (missingSections.length > 0) {
              core.warning(`PR description is missing recommended sections: ${missingSections.join(', ')}`);
            }

  pr-labels:
    name: Auto-label PR
    runs-on: ${{ inputs.runner_type }}
    needs: skip-if-draft
    if: needs.skip-if-draft.outputs.should_skip != 'true' && inputs.enable_auto_labeler

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Auto-label based on files
        uses: actions/labeler@v5
        with:
          repo-token: ${{ secrets.GITHUB_TOKEN }}
          configuration-path: ${{ inputs.labeler_config_path }}
          sync-labels: true

  pr-assignee:
    name: Check Assignee
    runs-on: ${{ inputs.runner_type }}
    needs: skip-if-draft
    if: needs.skip-if-draft.outputs.should_skip != 'true'

    steps:
      - name: Check for assignee
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.MANAGE_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const pr = context.payload.pull_request;
            if (pr.assignees.length === 0) {
              core.warning('This PR has no assignees. Consider assigning someone to review.');
            }

  pr-linked-issues:
    name: Check Linked Issues
    runs-on: ${{ inputs.runner_type }}
    needs: skip-if-draft
    if: needs.skip-if-draft.outputs.should_skip != 'true'

    steps:
      - name: Check for linked issues
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.MANAGE_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const body = context.payload.pull_request.body || '';
            const issueKeywords = ['closes', 'fixes', 'resolves', 'relates to'];

            let hasLinkedIssue = false;
            for (const keyword of issueKeywords) {
              if (body.toLowerCase().includes(keyword)) {
                hasLinkedIssue = true;
                break;
              }
            }

            if (!hasLinkedIssue) {
              core.warning('This PR does not appear to be linked to any issues. Consider linking related issues using keywords like "Closes #123" or "Fixes #456".');
            }

  pr-changelog:
    name: Check Changelog Update
    runs-on: ${{ inputs.runner_type }}
    needs: skip-if-draft
    if: needs.skip-if-draft.outputs.should_skip != 'true' && inputs.check_changelog

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check if CHANGELOG updated
        id: changelog
        run: |
          if git diff --name-only origin/${{ github.base_ref }}...HEAD | grep -q "CHANGELOG.md"; then
            echo "updated=true" >> $GITHUB_OUTPUT
          else
            echo "updated=false" >> $GITHUB_OUTPUT
          fi

      - name: Comment if CHANGELOG not updated
        if: steps.changelog.outputs.updated == 'false'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.MANAGE_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const labels = context.payload.pull_request.labels.map(l => l.name);

            // Skip for certain labels
            if (labels.includes('skip-changelog') || labels.includes('dependencies')) {
              return;
            }

            github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: 'Consider updating CHANGELOG.md to document this change. If this change doesn\'t need a changelog entry, add the `skip-changelog` label.'
            });

  pr-checks-summary:
    name: PR Checks Summary
    runs-on: ${{ inputs.runner_type }}
    needs: [pr-source-branch, pr-title, pr-size, pr-description, pr-labels, pr-assignee, pr-linked-issues, pr-changelog]
    if: always()

    steps:
      - name: Summary
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.MANAGE_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const checks = {
              'Source Branch': '${{ needs.pr-source-branch.result }}',
              'PR Title': '${{ needs.pr-title.result }}',
              'PR Size': '${{ needs.pr-size.result }}',
              'PR Description': '${{ needs.pr-description.result }}',
              'Auto-label': '${{ needs.pr-labels.result }}',
              'Assignee Check': '${{ needs.pr-assignee.result }}',
              'Linked Issues': '${{ needs.pr-linked-issues.result }}',
              'Changelog': '${{ needs.pr-changelog.result }}'
            };

            let summary = '## PR Checks Summary\n\n';
            for (const [check, result] of Object.entries(checks)) {
              const icon = result === 'success' ? '✅' : result === 'failure' ? '❌' : '⚠️';
              summary += `${icon} ${check}: ${result}\n`;
            }

            core.summary.addRaw(summary);
            await core.summary.write();

  # Slack notification
  notify:
    name: Notify
    needs: [skip-if-draft, pr-source-branch, pr-title, pr-size, pr-description, pr-labels, pr-assignee, pr-linked-issues, pr-changelog, pr-checks-summary]
    if: always() && needs.skip-if-draft.outputs.should_skip != 'true'
    uses: ./.github/workflows/slack-notify.yml
    with:
      status: ${{ (needs.pr-source-branch.result == 'failure' || needs.pr-title.result == 'failure' || needs.pr-description.result == 'failure') && 'failure' || 'success' }}
      workflow_name: "PR Validation"
      failed_jobs: ${{ needs.pr-source-branch.result == 'failure' && 'Source Branch, ' || '' }}${{ needs.pr-title.result == 'failure' && 'PR Title, ' || '' }}${{ needs.pr-description.result == 'failure' && 'PR Description' || '' }}
    secrets:
      SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
