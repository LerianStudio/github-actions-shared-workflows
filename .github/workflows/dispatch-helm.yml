name: "Dispatch to Helm Repository"

# Reusable workflow for dispatching repository_dispatch events to Helm chart repositories
# Sends a SINGLE dispatch with ALL components to enable single commit updates
#
# Usage:
#   dispatch-helm:
#     uses: LerianStudio/github-actions-shared-workflows/.github/workflows/dispatch-helm.yml@main
#     with:
#       helm_repository: org/helm-repo
#       chart: my-app
#       components_json: '[{"name":"backend","is_main":true},{"name":"frontend"}]'
#     secrets:
#       helm_repo_token: ${{ secrets.HELM_REPO_TOKEN }}

on:
  workflow_call:
    inputs:
      helm_repository:
        description: 'Helm repository to dispatch to (org/repo format)'
        type: string
        required: true
      event_type:
        description: 'Event type for repository_dispatch'
        type: string
        default: 'update-helm-chart'
      chart:
        description: 'Helm chart name'
        type: string
        required: true
      components_json:
        description: 'JSON array of components: [{"name":"backend","is_main":true},...]'
        type: string
        required: true
      components_base_path:
        description: 'Base path for components (default: components)'
        type: string
        default: 'components'
      version_file:
        description: 'Version file name relative to component path (default: VERSION)'
        type: string
        default: 'VERSION'
      env_file:
        description: 'Env example file name relative to component path (default: .env.example)'
        type: string
        default: '.env.example'
      detect_env_changes:
        description: 'Whether to detect new environment variables'
        type: boolean
        default: true
      runner_type:
        description: 'GitHub runner type to use'
        type: string
        default: 'ubuntu-latest'
    secrets:
      helm_repo_token:
        description: 'GitHub token with access to Helm repository (needs repo scope)'
        required: true

jobs:
  prepare-and-dispatch:
    name: Prepare and Dispatch
    runs-on: ${{ inputs.runner_type }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Process all components
        id: process
        run: |
          COMPONENTS_JSON='${{ inputs.components_json }}'
          BASE_PATH="${{ inputs.components_base_path }}"
          VERSION_FILE="${{ inputs.version_file }}"
          ENV_FILE="${{ inputs.env_file }}"
          DETECT_ENV="${{ inputs.detect_env_changes }}"
          BEFORE_SHA="${{ github.event.before }}"

          echo "Processing components: $COMPONENTS_JSON"

          # Initialize output array
          PROCESSED_COMPONENTS="["
          FIRST=true
          HAS_NEW_ENV_VARS=false

          # Process each component
          for row in $(echo "$COMPONENTS_JSON" | jq -c '.[]'); do
            COMP_NAME=$(echo "$row" | jq -r '.name')
            COMP_IS_MAIN=$(echo "$row" | jq -r '.is_main // false')
            COMP_PATH=$(echo "$row" | jq -r '.path // empty')
            COMP_VERSION=$(echo "$row" | jq -r '.version // empty')

            # Determine component path
            if [ -z "$COMP_PATH" ]; then
              COMP_PATH="${BASE_PATH}/${COMP_NAME}"
            fi

            echo "Processing component: $COMP_NAME (path: $COMP_PATH)"

            # Get version
            if [ -n "$COMP_VERSION" ]; then
              VERSION="$COMP_VERSION"
              echo "  Using provided version: $VERSION"
            elif [ -f "${COMP_PATH}/${VERSION_FILE}" ]; then
              VERSION=$(cat "${COMP_PATH}/${VERSION_FILE}" | tr -d '[:space:]')
              echo "  Version from file: $VERSION"
            else
              COMMIT_COUNT=$(git rev-list --count HEAD -- "${COMP_PATH}")
              SHORT_SHA=$(git rev-parse --short HEAD)
              VERSION="1.0.${COMMIT_COUNT}-${SHORT_SHA}"
              echo "  Generated version: $VERSION"
            fi

            # Detect new env vars
            ENV_VARS_JSON="{}"
            if [ "$DETECT_ENV" = "true" ]; then
              FULL_ENV_FILE="${COMP_PATH}/${ENV_FILE}"

              if [ -f "$FULL_ENV_FILE" ]; then
                CURRENT_VARS=$(grep -E "^[A-Z_][A-Z0-9_]*=" "$FULL_ENV_FILE" | cut -d'=' -f1 | sort || echo "")

                PREVIOUS_VARS=""
                if [ -n "$BEFORE_SHA" ] && [ "$BEFORE_SHA" != "0000000000000000000000000000000000000000" ]; then
                  PREVIOUS_VARS=$(git show "${BEFORE_SHA}:${FULL_ENV_FILE}" 2>/dev/null | grep -E "^[A-Z_][A-Z0-9_]*=" | cut -d'=' -f1 | sort || echo "")
                fi

                # Find new variables
                NEW_VARS=""
                if [ -n "$CURRENT_VARS" ]; then
                  while IFS= read -r var; do
                    if [ -n "$var" ] && ! echo "$PREVIOUS_VARS" | grep -q "^${var}$"; then
                      NEW_VARS="${NEW_VARS} ${var}"
                    fi
                  done <<< "$CURRENT_VARS"
                fi

                # Build JSON for new vars
                if [ -n "$(echo "$NEW_VARS" | tr -d '[:space:]')" ]; then
                  HAS_NEW_ENV_VARS=true
                  ENV_VARS_JSON="{"
                  FIRST_VAR=true
                  for var in $NEW_VARS; do
                    DEFAULT_VALUE=$(grep "^${var}=" "$FULL_ENV_FILE" | cut -d'=' -f2- | sed 's/"/\\"/g' || echo "")
                    if [ "$FIRST_VAR" = "true" ]; then
                      ENV_VARS_JSON="${ENV_VARS_JSON}\"${var}\":\"${DEFAULT_VALUE}\""
                      FIRST_VAR=false
                    else
                      ENV_VARS_JSON="${ENV_VARS_JSON},\"${var}\":\"${DEFAULT_VALUE}\""
                    fi
                  done
                  ENV_VARS_JSON="${ENV_VARS_JSON}}"
                  echo "  New env vars: $NEW_VARS"
                fi
              fi
            fi

            # Build component object
            COMP_OBJ="{\"name\":\"${COMP_NAME}\",\"version\":\"${VERSION}\",\"is_main\":${COMP_IS_MAIN},\"env_vars\":${ENV_VARS_JSON}}"

            if [ "$FIRST" = "true" ]; then
              PROCESSED_COMPONENTS="${PROCESSED_COMPONENTS}${COMP_OBJ}"
              FIRST=false
            else
              PROCESSED_COMPONENTS="${PROCESSED_COMPONENTS},${COMP_OBJ}"
            fi
          done

          PROCESSED_COMPONENTS="${PROCESSED_COMPONENTS}]"

          echo "Processed components: $PROCESSED_COMPONENTS"
          echo "has_new_env_vars=$HAS_NEW_ENV_VARS" >> $GITHUB_OUTPUT

          # Save to file to avoid escaping issues
          echo "$PROCESSED_COMPONENTS" > /tmp/components_payload.json

      - name: Dispatch to Helm repository
        run: |
          COMPONENTS=$(cat /tmp/components_payload.json)

          # Build the full payload
          PAYLOAD=$(jq -n \
            --arg chart "${{ inputs.chart }}" \
            --argjson components "$COMPONENTS" \
            --arg has_new_env_vars "${{ steps.process.outputs.has_new_env_vars }}" \
            --arg source_repo "${{ github.repository }}" \
            --arg source_sha "${{ github.sha }}" \
            --arg source_ref "${{ github.ref_name }}" \
            --arg source_actor "${{ github.actor }}" \
            '{
              chart: $chart,
              components: $components,
              has_new_env_vars: ($has_new_env_vars == "true"),
              source_repo: $source_repo,
              source_sha: $source_sha,
              source_ref: $source_ref,
              source_actor: $source_actor
            }')

          echo "Dispatching payload:"
          echo "$PAYLOAD" | jq .

          # Send dispatch
          curl -X POST \
            -H "Authorization: token ${{ secrets.helm_repo_token }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ inputs.helm_repository }}/dispatches" \
            -d "{\"event_type\":\"${{ inputs.event_type }}\",\"client_payload\":${PAYLOAD}}"

      - name: Summary
        run: |
          COMPONENTS=$(cat /tmp/components_payload.json)

          echo "### Dispatch Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Repository:** \`${{ inputs.helm_repository }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Chart:** \`${{ inputs.chart }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Components:**" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Component | Version | Is Main | New Env Vars |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|---------|---------|--------------|" >> $GITHUB_STEP_SUMMARY

          echo "$COMPONENTS" | jq -r '.[] | "| \(.name) | \(.version) | \(.is_main) | \(.env_vars | if . == {} then "-" else (. | keys | join(", ")) end) |"' >> $GITHUB_STEP_SUMMARY
